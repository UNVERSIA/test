<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>进食障碍眼动预测程序</title>

  <!-- 引入 Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&display=swap" rel="stylesheet" />
  <!-- ONNX Runtime -->
  <script src="https://cdn.jsdelivr.net/npm/onnxruntime-web/dist/ort.min.js"></script>
  <!-- jsPsych 相关脚本 -->
  <script src="https://unpkg.com/jspsych@8.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-preload@2.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-button-response@2.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-html-keyboard-response@2.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-image-keyboard-response@2.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-webgazer-init-camera@2.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-webgazer-calibrate@2.0.0"></script>
  <script src="https://unpkg.com/@jspsych/plugin-webgazer-validate@2.0.0"></script>
  <script src="https://cdn.jsdelivr.net/gh/jspsych/jspsych@jspsych@7.0.0/examples/js/webgazer/webgazer.js"></script>
  <script src="https://unpkg.com/@jspsych/extension-webgazer@1.0.3"></script>
  <script src="https://unpkg.com/@jspsych/plugin-call-function@1.0.0"></script>

  <style>
    /* ==== 全局样式 ==== */
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      height: 100%;
      font-family: 'Roboto', 'Microsoft YaHei', sans-serif;
      background: #f5f6f8;
      color: #333;
      overflow: hidden;
    }

    /* ==== 顶部导航栏 ==== */
    .header {
      width: 100%;
      background: linear-gradient(90deg, #2c3e50, #4b6082);
      padding: 15px 0;
      box-shadow: 0 2px 8px rgba(0, 0, 0, 0.15);
      position: fixed;
      top: 0;
      left: 0;
      z-index: 1001;
      display: flex;
      justify-content: center;
    }

    .header h1 {
      color: #fff;
      font-weight: 500;
      font-size: 1.6rem;
      letter-spacing: 1px;
    }

    /* ==== 内容容器 ==== */
    #jspsych-target {
      position: absolute;
      top: 70px;
      left: 0;
      width: 100%;
      height: calc(100vh - 70px);
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f5f6f8;
        z-index: 1;
    }
    #jspsych-target .jspsych-display-element {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #f5f6f8;
    }
    #jspsych-target .jspsych-content {
      width: 100%;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      max-height: 100%;
    }

    /* ==== 图片展示区 ==== */
    .stimulus-container {
      width: 80%;
      max-width: 1000px;
      height: 70vh;
      margin: 0 auto;
      padding: 20px;
      border-radius: 20px;
      background: #ffffff;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
    }
    .stimulus-image {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      border-radius: 10px;
    }

    /* ==== 区域划分 ==== */
    .left-region, .right-region {
      position: absolute;
      top: 20px;
      bottom: 20px;
      width: 50%;
      /* 调试时取消注释以显示区域边界 */
      /* background: rgba(255, 0, 0, 0.1); */
    }
    .left-region {
      left: 20px;
    }
    .right-region {
      right: 20px;
    }

    /* ==== 中央固定十字 ==== */
    .central-fixation {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 80px;
      color: #555;
      -webkit-user-select: none;
      user-select: none;
      z-index: 999;
      display: none;
    }

    /* ==== 眼动追踪注视点（已禁用） ==== */
    .gaze-point {
      position: absolute;
      width: 10px;
      height: 10px;
      background-color: red;
      border-radius: 50%;
      pointer-events: none;
      z-index: 9999;
      display: none !important; /* 确保小红点被隐藏 */
    }

    /* ==== 按钮样式 ==== */
    button {
      background: linear-gradient(90deg, #2980b9, #3498db);
      border: none;
      color: #fff;
      padding: 14px 36px;
      text-align: center;
      font-size: 1rem;
      margin: 6px;
      cursor: pointer;
      border-radius: 8px;
      transition: background 0.3s ease, transform 0.2s ease, box-shadow 0.2s ease;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    button:hover {
      background: linear-gradient(90deg, #2572a5, #2c82c2);
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
    }

    .jspsych-html-button-response .jspsych-button-container {
      display: flex;
      justify-content: center;
      flex-wrap: wrap;
      margin-top: 20px;
    }

    /* ==== 居中文字模块 ==== */
    .centered-text {
      text-align: center;
      padding: 20px 30px;
      color: #444;
      line-height: 1.6;
      max-width: 800px;
    }
    .centered-text p {
      font-size: 1.5rem;
      margin-bottom: 1rem;
    }

    /* ==== 页脚 ==== */
    .footer {
      position: fixed;
      bottom: 10px;
      left: 50%;
      transform: translateX(-50%);
      color: #888;
      font-size: 0.9rem;
      letter-spacing: 0.5px;
    }

    /* ==== 登录表单样式 ==== */
    .login-container {
      width: 700px;
      background: #fff;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
      text-align: center;
      margin: 0 auto;
    }
    .login-container h2 {
      color: #2c3e50;
      margin-bottom: 25px;
      font-weight: 500;
    }
    .form-group {
      margin-bottom: 20px;
      text-align: left;
    }
    .form-group label {
      display: block;
      margin-bottom: 8px;
      font-weight: 500;
      color: #555;
    }
    .form-group input, .form-group select {
      width: 100%;
      padding: 12px 15px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 1rem;
      transition: border-color 0.3s;
    }
    .form-group input:focus, .form-group select:focus {
      border-color: #3498db;
      outline: none;
      box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.2);
    }
    .login-button {
      background: linear-gradient(90deg, #2980b9, #3498db);
      border: none;
      color: #fff;
      padding: 14px 36px;
      text-align: center;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s ease;
      width: 100%;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .login-button:hover {
      background: linear-gradient(90deg, #2572a5, #2c82c2);
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
    }

    /* 新增：实验次数显示样式 */
    .session-display {
      background: #f0f7ff;
      border-radius: 12px;
      padding: 15px;
      margin: 20px 0;
      border: 2px solid #d0e4ff;
      font-size: 1.3rem;
      font-weight: 500;
    }
    .session-display span {
      color: #2980b9;
      font-weight: 600;
    }

    /* ==== 数据报告样式 ==== */
    .data-report {
      max-width: 800px;
      background: #fff;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
      text-align: left;
      font-family: 'Courier New', monospace;
      max-height: 80vh;
      overflow-y: auto;
    }
    .data-report h2 {
      text-align: center;
      margin-bottom: 20px;
      color: #2c3e50;
      font-weight: 500;
    }
    .data-report pre {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      overflow-x: auto;
      white-space: pre-wrap;
      word-wrap: break-word;
      font-size: 0.9rem;
      line-height: 1.5;
    }
    .copy-button {
      background: linear-gradient(90deg, #27ae60, #2ecc71);
      border: none;
      color: #fff;
      padding: 12px 28px;
      text-align: center;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s ease;
      margin-top: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .copy-button:hover {
      background: linear-gradient(90deg, #219653, #27ad60);
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
    }
    .github-button {
      background: linear-gradient(90deg, #24292e, #2d3338);
      border: none;
      color: #fff;
      padding: 12px 28px;
      text-align: center;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s ease;
      margin-top: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .github-button:hover {
      background: linear-gradient(90deg, #1a1e21, #22272b);
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
    }
    /* 新增：保存按钮样式 */
    .save-button {
      background: linear-gradient(90deg, #f39c12, #e67e22);
      border: none;
      color: #fff;
      padding: 12px 28px;
      text-align: center;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s ease;
      margin-top: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .save-button:hover {
      background: linear-gradient(90deg, #d35400, #e67e22);
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
    }

    /* 退出按钮 */
    .exit-button {
      background: linear-gradient(90deg, #e74c3c, #c0392b);
      border: none;
      color: #fff;
      padding: 12px 28px;
      text-align: center;
      font-size: 1rem;
      cursor: pointer;
      border-radius: 8px;
      transition: all 0.3s ease;
      margin-top: 20px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
    }
    .exit-button:hover {
      background: linear-gradient(90deg, #c0392b, #a93226);
      transform: translateY(-2px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.15);
    }

    /* ==== 状态消息 ==== */
    .status-message {
      margin-top: 20px;
      padding: 15px;
      border-radius: 8px;
      text-align: center;
      font-weight: 500;
    }
    .status-success {
      background: #d4edda;
      color: #155724;
      border: 1px solid #c3e6cb;
    }
    .status-error {
      background: #f8d7da;
      color: #721c24;
      border: 1px solid #f5c6cb;
    }
    .status-loading {
      background: #cce5ff;
      color: #004085;
      border: 1px solid #b8daff;
    }
    .status-warning {
      background: #fff3cd;
      color: #856404;
      border: 1px solid #ffeeba;
    }

    /* 验证码弹窗 */
    .auth-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0,0,0,0.7);
      z-index: 3000;
      justify-content: center;
      align-items: center;
    }
    .auth-content {
      background: white;
      padding: 30px;
      border-radius: 15px;
      text-align: center;
      width: 400px;
      max-width: 90%;
      box-shadow: 0 15px 30px rgba(0,0,0,0.3);
    }
    .auth-content h3 {
      margin-bottom: 20px;
      color: #2c3e50;
    }
    .auth-input {
      width: 100%;
      padding: 12px;
      margin-bottom: 20px;
      border: 1px solid #ddd;
      border-radius: 8px;
      font-size: 1rem;
    }
    .auth-buttons {
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }
    .auth-button {
      flex: 1;
      padding: 10px;
      border: none;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      transition: all 0.3s;
    }
    .auth-confirm {
      background: #27ae60;
      color: white;
    }
    .auth-confirm:hover {
      background: #219653;
    }
    .auth-cancel {
      background: #e74c3c;
      color: white;
    }
    .auth-cancel:hover {
      background: #c0392b;
    }
    .auth-error {
      color: #e74c3c;
      margin-top: 10px;
      display: none;
    }

    /* ==== 权限提示和错误提示样式 ==== */
    .permission-alert {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 15px 30px rgba(0,0,0,0.3);
      text-align: center;
      z-index: 2000;
      max-width: 90%;
      width: 500px;
      display: none;
    }

    .permission-alert h3 {
      color: #e74c3c;
      margin-bottom: 20px;
    }

    .permission-alert p {
      margin: 10px 0;
      line-height: 1.6;
    }

    .permission-alert .warning {
      color: #e74c3c;
      font-weight: bold;
    }

    .permission-alert .browser-warning {
      background: #f8d7da;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      text-align: left;
    }

    .permission-alert .protocol-warning {
      background: #fff3cd;
      padding: 15px;
      border-radius: 8px;
      margin: 15px 0;
      text-align: left;
    }

    /* ==== 初始化状态面板 ==== */
    .init-status-panel {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 15px;
      border-radius: 8px;
      max-width: 400px;
      z-index: 2000;
      font-size: 14px;
      display: none;
    }

    .init-status-panel h4 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #3498db;
      border-bottom: 1px solid #3498db;
      padding-bottom: 5px;
    }

    .init-status-panel .status-item {
      margin-bottom: 8px;
      display: flex;
      justify-content: space-between;
    }

    .init-status-panel .status-label {
      font-weight: bold;
      margin-right: 10px;
    }

    .init-status-panel .status-value {
      color: #2ecc71;
    }

    .init-status-panel .status-error {
      color: #e74c3c;
    }

    .init-status-panel .status-warning {
      color: #f39c12;
    }

    .debug-toggle {
      position: fixed;
      bottom: 20px;
      left: 20px;
      background: #3498db;
      color: white;
      border: none;
      padding: 8px 15px;
      border-radius: 5px;
      cursor: pointer;
      z-index: 2001;
    }

    /* ==== 错误处理面板 ==== */
    .error-panel {
      background: #f8d7da;
      border-left: 4px solid #e74c3c;
      padding: 15px;
      margin: 20px 0;
      border-radius: 0 8px 8px 0;
      text-align: left;
    }

    .error-panel h4 {
      color: #721c24;
      margin-top: 0;
      margin-bottom: 10px;
    }

    .error-panel ul {
      padding-left: 20px;
      margin-bottom: 10px;
    }

    .error-panel li {
      margin-bottom: 5px;
    }

    /* ==== 数据表格样式 ==== */
    .results-table {
      width: 100%;
      border-collapse: collapse;
      margin: 20px 0;
      font-size: 0.9em;
      font-family: sans-serif;
      box-shadow: 0 0 20px rgba(0, 0, 0, 0.15);
    }
    .results-table thead tr {
      background-color: #2980b9;
      color: #ffffff;
      text-align: left;
    }
    .results-table th,
    .results-table td {
      padding: 12px 15px;
      border: 1px solid #dddddd;
    }
    .results-table tbody tr {
      border-bottom: 1px solid #dddddd;
    }
    .results-table tbody tr:nth-of-type(even) {
      background-color: #f3f3f3;
    }
    .results-table tbody tr:last-of-type {
      border-bottom: 2px solid #2980b9;
    }

    /* ==== 调试信息面板 ==== */
    .debug-panel {
      position: fixed;
      top: 70px;
      right: 20px;
      background: rgba(0,0,0,0.7);
      color: white;
      padding: 15px;
      border-radius: 8px;
      max-width: 400px;
      z-index: 2000;
      font-size: 12px;
      display: none;
    }

    .debug-panel h4 {
      margin-top: 0;
      margin-bottom: 10px;
      color: #3498db;
      border-bottom: 1px solid #3498db;
      padding-bottom: 5px;
    }

    .debug-panel .debug-item {
      margin-bottom: 8px;
    }

    .debug-panel .debug-label {
      font-weight: bold;
      margin-right: 10px;
    }

    .debug-panel .debug-value {
      color: #2ecc71;
    }

    .debug-panel .debug-error {
      color: #e74c3c;
    }

    /* ==== 人脸检测提示 ==== */
    .face-detection-help {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 30px;
      border-radius: 15px;
      box-shadow: 0 15px 30px rgba(0,0,0,0.3);
      text-align: center;
      z-index: 2000;
      max-width: 90%;
      width: 500px;
      display: none;
    }

    .face-detection-help h3 {
      color: #2980b9;
      margin-bottom: 20px;
    }

    .face-detection-help ul {
      text-align: left;
      margin: 20px 0;
      padding-left: 20px;
    }

    .face-detection-help li {
      margin-bottom: 10px;
    }

    .face-detection-help .camera-feed {
      width: 100%;
      height: 200px;
      background: #eee;
      border-radius: 8px;
      margin: 15px 0;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    .face-detection-help .camera-feed video {
      max-width: 100%;
      max-height: 100%;
    }

    .face-detection-help .retry-button {
      background: #3498db;
      color: white;
      border: none;
      padding: 12px 24px;
      border-radius: 8px;
      cursor: pointer;
      font-size: 1rem;
      margin-top: 15px;
    }

    /* ==== 预测结果样式 ==== */
    .prediction-result h3 {
      color: #2c3e50;
      margin-bottom: 15px;
      border-bottom: 2px solid #e9ecef;
      padding-bottom: 10px;
    }

    .prediction-features h4 {
      color: #2c3e50;
      margin-bottom: 10px;
    }

    .prediction-features ul {
      padding-left: 20px;
    }

    .prediction-features li {
      margin-bottom: 8px;
    }
/* ==== 诊断报告样式 ==== */
  .diagnostic-report {
    max-width: 800px;
    max-height: 80vh; /* 限制最大高度为视口的80% */
    overflow-y: auto; /* 添加垂直滚动条 */
    background: #fff;
    padding: 30px;
    border-radius: 15px;
    box-shadow: 0 12px 24px rgba(0, 0, 0, 0.1);
    margin: 20px auto;
    text-align: left;
    font-family: 'Roboto', 'Microsoft YaHei', sans-serif;
  }

  .diagnostic-report h3 {
    color: #2c3e50;
    text-align: center;
    margin-bottom: 20px;
    border-bottom: 2px solid #e9ecef;
    padding-bottom: 10px;
  }

  .diagnostic-report h4 {
    color: #2c3e50;
    margin-top: 20px;
    margin-bottom: 10px;
    font-size: 1.3em; /* 增大建议标题字体 */
  }

  .diagnostic-report ul {
    padding-left: 20px;
    margin-bottom: 15px;
  }

  .diagnostic-report li {
    margin-bottom: 8px;
    font-size: 1.1em; /* 增大建议内容字体 */
    line-height: 1.6; /* 增加行高提高可读性 */
  }

  .report-disclaimer {
    margin-top: 30px;
    padding-top: 20px;
    border-top: 1px solid #e9ecef;
    font-size: 0.8em; /* 缩小免责声明字体 */
    color: #6c757d;
    line-height: 1.4; /* 调整行高 */
  }

  /* 确保整个报告区域可以滚动 */
  .jspsych-content {
    overflow-y: auto; /* 允许内容区域滚动 */
    max-height: calc(100vh - 70px); /* 减去顶部导航栏高度 */
  }

/* ==== 用户手册侧边栏样式 ==== */
.user-manual-sidebar {
  position: fixed;
  top: 70px;
  right: -400px;
  width: 400px;
  height: calc(100vh - 70px);
  background: rgba(240, 240, 240, 0.95); /* 改为浅灰色有透明度 */
  box-shadow: -2px 0 15px rgba(0, 0, 0, 0.1);
  z-index: 999;
  transition: right 0.3s ease;
  overflow-y: auto;
  padding: 20px;
  backdrop-filter: blur(5px); /* 添加毛玻璃效果 */
}

.user-manual-sidebar.active {
  right: 0;
}

.user-manual-toggle {
  position: fixed;
  top: 50%; /* 垂直居中 */
  right: 0; /* 紧贴网页最右边 */
  transform: translateY(-50%); /* 垂直居中调整 */
  background: linear-gradient(135deg, #2980b9 0%, #3498db 100%); /* 改为蓝色系 */
  color: white;
  border: none;
  padding: 20px 10px; /* 调整内边距，因为竖排 */
  border-radius: 10px 0 0 10px; /* 左上和左下圆角，右上和右下直角 */
  cursor: pointer;
  z-index: 998;
  font-size: 16px;
  font-weight: 500;
  transition: all 0.3s ease;
  box-shadow: -2px 0 5px rgba(0, 0, 0, 0.2); /* 阴影在左侧 */
  writing-mode: vertical-rl; /* 垂直排列，从右向左 */
  text-orientation: mixed;
  display: flex;
  align-items: center;
  justify-content: center;
  /* 去掉水平排列的gap，因为竖排 */
  gap: 0;
}

.user-manual-toggle:hover {
  background: linear-gradient(135deg, #2572a5 0%, #2c82c2 100%);
  transform: translateY(-50%) translateX(-5px); /* 悬停时向左移动一点 */
  box-shadow: -5px 0 15px rgba(0, 0, 0, 0.3);
  /* 取消水平悬停时的padding-right变化 */
  padding-right: 10px; /* 保持竖排时的内边距 */
}

/* 去掉书本符号 */
.user-manual-toggle::before {
  content: ""; /* 设为空 */
  display: none;
}

.user-manual-content {
  height: 100%;
}

.user-manual-content h2 {
  color: #2c3e50;
  margin-bottom: 20px;
  padding-bottom: 10px;
  border-bottom: 2px solid #e9ecef;
  text-align: center; /* 标题居中 */
}

.user-manual-content h3 {
  color: #2c3e50;
  margin: 20px 0 10px 0;
  font-size: 1.2em;
}

.user-manual-content p, .user-manual-content li {
  line-height: 1.6;
  margin-bottom: 10px;
  font-size: 14px;
}

.user-manual-content ul {
  padding-left: 20px;
  margin-bottom: 15px;
}

.user-manual-content .important {
  background: #fff3cd;
  padding: 10px;
  border-radius: 5px;
  border-left: 4px solid #ffc107;
  margin: 15px 0;
}

.user-manual-content .warning {
  background: #f8d7da;
  padding: 10px;
  border-radius: 5px;
  border-left: 4px solid #dc3545;
  margin: 15px 0;
}

.user-manual-overlay {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.5);
  z-index: 997;
  display: none;
}

.user-manual-overlay.active {
  display: block;
}

/* 修改：关闭按钮样式 - 移到右上角 */
.manual-close-btn {
  position: absolute;
  top: 15px;
  right: 15px; /* 改为右上角 */
  left: auto; /* 清除左边的定位 */
  background: #6c757d; /* 改为灰色 */
  color: white;
  border: none;
  width: 35px;
  height: 35px;
  border-radius: 50%;
  cursor: pointer;
  font-size: 18px;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.3s ease;
  z-index: 1000;
}

.manual-close-btn:hover {
  background: #495057;
  transform: scale(1.1);
}

/* 优化提示框样式 */
.min-time-message {
  background: linear-gradient(135deg, #6c757d 0%, #495057 100%); /* 改为灰色系 */
  color: white;
  padding: 12px 15px;
  border-radius: 8px;
  margin: 10px 0;
  text-align: center;
  font-size: 13px;
  display: none;
  box-shadow: 0 4px 12px rgba(108, 117, 125, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.2);
}

/* 祝福语样式 */
.final-blessing {
  text-align: center;
  margin: 20px 0 10px 0;
  padding: 15px;
  background: linear-gradient(135deg, #2980b9 0%, #3498db 100%); /* 改为蓝色系 */
  color: white;
  border-radius: 10px;
  font-weight: 600;
  box-shadow: 0 4px 15px rgba(41, 128, 185, 0.3);
  border: 1px solid rgba(255, 255, 255, 0.2);
}
/* 底部留空区域 */
.manual-bottom-space {
  height: 50px;
}
/* 新增：抖动动画 */
@keyframes shake {
  0%, 100% { transform: translateX(0); }
  25% { transform: translateX(-5px); }
  75% { transform: translateX(5px); }
}

/* 确保手册内容区域可滚动 */
.user-manual-content {
  height: 100%;
  overflow-y: auto;
  padding-right: 10px; /* 为滚动条留出空间 */
}
  </style>
</head>

<body>
  <!-- 顶部导航栏 -->
  <div class="header">
    <h1>进食障碍眼动预测程序</h1>
  </div>

<!-- 用户手册侧边栏 -->
<div class="user-manual-sidebar" id="user-manual-sidebar">
  <div class="user-manual-content" id="user-manual-content">
    <button class="manual-close-btn" id="manual-close-btn">×</button>
    <h2>用户适应手册</h2>

    <h3>1. 测量前的环境准备</h3>
    <p><strong>推荐浏览器：</strong>请使用 Google Chrome 或 Microsoft Edge 浏览器访问系统。</p>
    <div class="important">
      <strong>重要提示：</strong>在整个测量周期内，请始终使用同一浏览器，不可中途更换，以免造成数据丢失或异常。
    </div>

    <p><strong>摄像头准备：</strong>请确保您的电脑内置或外接摄像头可正常使用，并在浏览器中开启摄像头权限。</p>
    <p><strong>提示：</strong>开始前请关闭其他可能占用摄像头的软件或网页（如微信、Zoom等），确保摄像头可被测量网页独占使用。</p>

    <p><strong>网络环境：</strong>建议使用稳定、高速的家庭宽带或手机热点，避免在测量过程中网络发生中断。</p>
    <p>若页面加载缓慢或报错：可尝试暂时关闭防火墙或安全软件（如360、电脑管家），或切换网络环境后刷新重试。</p>

    <h3>2. 测量操作流程</h3>
    <p>请严格按以下步骤执行，以保证数据有效：</p>
    <ul>
      <li><strong>a) 访问系统：</strong>在地址栏输入测量页面地址并打开页面（首次加载可能较慢，请耐心等待，必要时可刷新重试）。</li>
      <li><strong>b) 登录与信息填写：</strong>输入您的唯一实验ID；如实填写性别、年龄等基本信息；点击【开始实验】进入系统。</li>
      <li><strong>c) 权限授予：</strong>首次使用时，浏览器会请求摄像头权限，请点击"允许"。</li>
      <li><strong>d) 校准与测量：</strong>请保持面部位于界面中的绿色校准框内，并尽量保持头部稳定；按屏幕提示完成注视点校准及后续自由浏览任务。</li>
      <li><strong>e) 数据提交：</strong>测量结束后系统将自动上传数据；请耐心等待上传完成，直至出现结束提示后再关闭页面。</li>
    </ul>
    <div class="warning">
      如界面提示"数据上传失败"，请按提示手动下载数据文件，并及时提交给实验负责人。
    </div>

    <h3>3. 常见问题处理</h3>
    <ul>
      <li>如反复出现"The experiment failed to load..."等错误提示，尝试刷新页面或更换网络环境后重新登录；</li>
      <li>如遇持续技术障碍，请联系实验支持人员并提供您的ID与问题描述。</li>
    </ul>

    <h3>4. 注意事项</h3>
    <ul>
      <li>请在安静、光线稳定的环境下进行测量；</li>
      <li>测量过程中请尽量避免大幅移动或与他人交谈；</li>
      <li>如有任何身体不适或主观困难，可暂停任务并联系实验人员。</li>
    </ul>

    <h3>5. 联系我们</h3>
    <p>如您在使用过程中遇到任何问题，请通过以下方式联系技术支持：2126660684@qq.com</p>

    <div class="final-blessing">
      <strong>------祝您测量顺利！------</strong>
    </div>

    <div class="manual-bottom-space"></div>
  </div>
</div>

<!-- 手册切换按钮 -->
<button class="user-manual-toggle" id="user-manual-toggle">用户适应手册</button>

<!-- 遮罩层 -->
<div class="user-manual-overlay" id="user-manual-overlay"></div>

  <!-- 中央固定十字 -->
  <div id="central-fixation" class="central-fixation">+</div>

  <!-- 眼动追踪注视点（已禁用） -->
  <div id="gaze-point" class="gaze-point"></div>

  <!-- 验证码弹窗 -->
  <div class="auth-modal" id="auth-modal">
    <div class="auth-content">
      <h3>请输入验证码以查看GitHub记录</h3>
      <input type="text" class="auth-input" id="auth-code" placeholder="输入验证码" />
      <div class="auth-error" id="auth-error">验证码错误，无权限查看</div>
      <div class="auth-buttons">
        <button class="auth-button auth-cancel" id="auth-cancel">返回</button>
        <button class="auth-button auth-confirm" id="auth-confirm">确认</button>
      </div>
    </div>
  </div>

  <!-- 摄像头权限提示 -->
  <div id="camera-permission-alert" class="permission-alert" style="display:none;"></div>

  <!-- 人脸检测帮助 -->
  <div class="face-detection-help" id="face-detection-help">
    <h3>人脸检测问题</h3>
    <p>系统无法检测到您的人脸，请尝试以下方法：</p>
    <ul>
      <li>确保光线充足，避免背光或过暗环境</li>
      <li>调整摄像头位置，使您的脸部清晰可见</li>
      <li>移除可能遮挡脸部的物品（如帽子、墨镜）</li>
      <li>尝试调整与摄像头的距离（约50-70厘米）</li>
    </ul>
    <div class="camera-feed" id="camera-preview">
      <p>摄像头预览将在这里显示</p>
    </div>
    <button class="retry-button" id="retry-face-detection">重试检测</button>
  </div>

  <!-- 初始化状态面板 -->
  <div class="init-status-panel" id="init-status-panel">
    <h4>眼动追踪初始化状态</h4>
    <div class="status-item">
      <span class="status-label">摄像头状态:</span>
      <span class="status-value" id="status-camera">检测中...</span>
    </div>
    <div class="status-item">
      <span class="status-label">Webgazer状态:</span>
      <span class="status-value" id="status-webgazer">未初始化</span>
    </div>
    <div class="status-item">
      <span class="status-label">权限状态:</span>
      <span class="status-value" id="status-permission">未知</span>
    </div>
    <div class="status-item">
      <span class="status-label">安全环境:</span>
      <span class="status-value" id="status-security">检测中...</span>
    </div>
    <div class="status-item">
      <span class="status-label">人脸检测:</span>
      <span class="status-value" id="status-face">未检测</span>
    </div>
    <div class="status-item">
      <span class="status-label">错误信息:</span>
      <span class="status-value" id="status-error">无</span>
    </div>
  </div>

  <!-- 调试信息面板 -->
  <div class="debug-panel" id="debug-panel">
    <h4>眼动数据调试信息</h4>
    <div class="debug-item">
      <span class="debug-label">当前试次:</span>
      <span class="debug-value" id="debug-trial">-</span>
    </div>
    <div class="debug-item">
      <span class="debug-label">数据点数量:</span>
      <span class="debug-value" id="debug-data-points">0</span>
    </div>
    <div class="debug-item">
      <span class="debug-label">左区域注视:</span>
      <span class="debug-value" id="debug-left-gaze">0ms</span>
    </div>
    <div class="debug-item">
      <span class="debug-label">右区域注视:</span>
      <span class="debug-value" id="debug-right-gaze">0ms</span>
    </div>
    <div class="debug-item">
      <span class="debug-label">首视点区域:</span>
      <span class="debug-value" id="debug-first-fixation">-</span>
    </div>
    <div class="debug-item">
      <span class="debug-label">回视次数:</span>
      <span class="debug-value" id="debug-regressions">0</span>
    </div>
  </div>

  <button class="debug-toggle" id="debug-toggle">显示调试信息</button>

  <!-- jsPsych 渲染目标容器 -->
  <div id="jspsych-target"></div>

  <!-- 页脚 -->
  <div class="footer">2025 北京师范大学 Eye—ED 项目组联合出品。</div>

  <script>
/* ==== 用户手册功能 ==== */
function initUserManual() {
  const sidebar = document.getElementById('user-manual-sidebar');
  const toggleBtn = document.getElementById('user-manual-toggle');
  const closeBtn = document.getElementById('manual-close-btn');
  const overlay = document.getElementById('user-manual-overlay');

  // 新增：手册状态变量
  let isFirstOpen = true;
  let hasScrolledToBottom = false;
  let scrollCheckInterval = null;

  // 页面加载后立即自动展开手册
  setTimeout(() => {
    openManual();
  }, 500);

  // 切换按钮点击事件
  let debounceTimer;
  toggleBtn.addEventListener('click', function() {
    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      if (sidebar.classList.contains('active')) {
        closeManual();
      } else {
        openManual();
      }
    }, 100);
  });

  // 关闭按钮点击事件
  closeBtn.addEventListener('click', function() {
    if (isFirstOpen && !hasScrolledToBottom) {
      const prompt = document.getElementById('scroll-prompt');
      if (prompt) {
        prompt.style.display = 'block';
        prompt.style.animation = 'shake 0.5s ease-in-out';
        setTimeout(() => {
          prompt.style.animation = '';
        }, 500);
      }
      return;
    }
    closeManual();
  });

  // 遮罩层点击事件
  overlay.addEventListener('click', function() {
    closeManual();
  });

  // 键盘ESC键关闭手册
  document.addEventListener('keydown', function(e) {
    if (e.key === 'Escape' && sidebar.classList.contains('active')) {
      closeManual();
    }
  });

  function openManual() {
    sidebar.classList.add('active');
    overlay.classList.add('active');
    toggleBtn.style.display = 'none';

    if (isFirstOpen) {
      hasScrolledToBottom = false;
      closeBtn.disabled = true;
      closeBtn.style.opacity = '0.5';
      closeBtn.style.cursor = 'not-allowed';
      closeBtn.title = '请滑动到底部阅读完整内容后关闭';
      addScrollPrompt();
      startScrollDetection();
    } else {
      closeBtn.disabled = false;
      closeBtn.style.opacity = '1';
      closeBtn.style.cursor = 'pointer';
      closeBtn.title = '';
    }
  }

  function closeManual() {
    if (isFirstOpen && !hasScrolledToBottom) {
      return;
    }

    if (isFirstOpen) {
      isFirstOpen = false;
    }

    sidebar.classList.remove('active');
    overlay.classList.remove('active');
    stopScrollDetection();

    setTimeout(() => {
      toggleBtn.style.display = 'flex';
    }, 300);
  }

  function addScrollPrompt() {
    let prompt = document.getElementById('scroll-prompt');
    if (!prompt) {
      prompt = document.createElement('div');
      prompt.id = 'scroll-prompt';
      prompt.className = 'min-time-message';
      prompt.innerHTML = '请滑动到底部阅读完整内容后关闭手册';
      prompt.style.display = 'block';
      prompt.style.marginTop = '10px';
      sidebar.querySelector('.user-manual-content').appendChild(prompt);
    }
  }

  function startScrollDetection() {
    scrollCheckInterval = setInterval(() => {
      const content = sidebar.querySelector('.user-manual-content');
      const scrollTop = content.scrollTop;
      const scrollHeight = content.scrollHeight;
      const clientHeight = content.clientHeight;

      if (scrollTop + clientHeight >= scrollHeight - 50) {
        hasScrolledToBottom = true;
        closeBtn.disabled = false;
        closeBtn.style.opacity = '1';
        closeBtn.style.cursor = 'pointer';
        closeBtn.title = '';

        const prompt = document.getElementById('scroll-prompt');
        if (prompt) {
          prompt.style.display = 'none';
        }

        clearInterval(scrollCheckInterval);
        scrollCheckInterval = null;
      }
    }, 500);
  }

  function stopScrollDetection() {
    if (scrollCheckInterval) {
      clearInterval(scrollCheckInterval);
      scrollCheckInterval = null;
    }
  }

  // 页面加载完成后初始化
  document.addEventListener('DOMContentLoaded', function() {
    const jsPsychTarget = document.getElementById('jspsych-target');
    if (jsPsychTarget) {
      jsPsychTarget.style.zIndex = '1';
    }
    toggleBtn.style.display = 'flex';
  });
}

// 在页面加载完成后初始化手册功能
document.addEventListener('DOMContentLoaded', initUserManual);
    /* ==== 模型相关变量 ==== */
let onnxSession = null;
let preprocessingConfig = null;
let modelLoaded = false;
    /* ==== 用户信息存储 ==== */
    let userInfo = null;
    let cameraPermissionDenied = false; // 摄像头权限状态
    let webgazerInitialized = false;   // Webgazer初始化状态
    let gazeData = []; // 存储每个试次的眼动数据
    let gazeUpdateInterval; // 眼动数据更新间隔
    let faceDetectionAttempts = 0; // 人脸检测尝试次数
/* ==== 诊断报告模板 ==== */
const diagnosticReports = {
  normal: `
    <div class="diagnostic-report">
      <h3>进食障碍风险眼动测评报告</h3>
      <p><strong>报告编号：</strong>REPORT-{reportId}</p>
      <p><strong>测评日期：</strong>{reportDate}</p>
      <p><strong>姓名：</strong>{subjectId}</p>

      <p>尊敬的参与者，感谢您完成本次测评。您的整体进食障碍风险等级评估为：<strong>健康</strong>。</p>

      <p>您的注意模式与健康人群相似，未显示出显著的进食障碍相关认知偏差。</p>

      <h4>根据您的风险等级，为您提供以下参考建议：</h4>
      <ul>
        <li><strong>祝贺您！您的认知习惯目前非常健康。请继续保持均衡的饮食和积极的身体意象。</li>
        <li><strong>建议：</strong>
          <ul>
            <li>保持当前良好的生活习惯。</li>
            <li>可以阅读相关科普资料，增进对心理健康的认识，起到预防作用。</li>
            <li>如果您未来感到压力或困扰，随时可以重新测评。</li>
          </ul>
        </li>
      </ul>

      <div class="report-disclaimer">
        <p><strong>免责声明：</strong>本报告由人工智能算法生成，仅作为筛查和参考工具，不能作为临床诊断的唯一依据。最终的诊断必须由合格的医疗专业人员通过面谈和评估做出。</p>
        <p><strong>隐私保护：</strong>您的所有测评数据都将被严格保密，仅用于为您生成此报告。</p>
        <p><strong>获取帮助：</strong>全国心理援助热线：12356</p>
        <p>感谢您的信任。关爱心理健康，是爱自己最重要的一步。</p>
      </div>
    </div>
  `,

  abnormal: `
    <div class="diagnostic-report">
      <h3>进食障碍风险眼动测评报告</h3>
      <p><strong>报告编号：</strong>REPORT-{reportId}</p>
      <p><strong>测评日期：</strong>{reportDate}</p>
      <p><strong>姓名：</strong>{subjectId}</p>

      <p>尊敬的参与者，感谢您完成本次测评。您的整体进食障碍风险等级评估为：<strong>异常</strong>。</p>

      <p>您的注意模式显示出明显的进食障碍认知偏差，建议寻求专业咨询或评估。</p>

      <h4>根据您的风险等级，为您提供以下参考建议：</h4>
      <ul>
        <li><strong>您的认知模式表明，食物和体型问题可能已对您造成了一定困扰，并影响了您的注意力分配。</li>
        <li><strong>建议：</strong>
          <ul>
            <li><strong>专业咨询：</strong>我们强烈建议您与心理咨询师或辅导员进行一次谈话。他们可以为您提供专业的评估和支持。这并不是一件可怕的事，而是关爱自己的表现。</li>
            <li><strong>行动步骤：</strong>您可以联系：全国心理援助热线：12356 或 北京心理援助热线：010-82951332。</li>
            <li><strong>避免独自挣扎：</strong>与一位您信任的朋友或家人聊聊您的感受。</li>
          </ul>
        </li>
      </ul>

      <div class="report-disclaimer">
        <p><strong>免责声明：</strong>本报告由人工智能算法生成，仅作为筛查和参考工具，不能作为临床诊断的唯一依据。最终的诊断必须由合格的医疗专业人员通过面谈和评估做出。</p>
        <p><strong>隐私保护：</strong>您的所有测评数据都将被严格保密，仅用于为您生成此报告。</p>
        <p><strong>获取帮助：</strong>全国心理援助热线：12356</p>
        <p>感谢您的信任。关爱心理健康，是爱自己最重要的一步。</p>
      </div>
    </div>
  `
};
    /* ==== 眼动数据分析变量 ==== */
    let containerRect = null; // 存储图片容器位置信息
    let analysisResults = {
      food: {
        dwellTime: 0, // 注视时间（高热量-低热量）
        firstFixation: 0, // 首视点数目（高热量-低热量）
        regressionCount: 0 // 回视次数
      },
      body: {
        dwellTime: 0, // 注视时间（胖子-瘦子）
        firstFixation: 0, // 首视点数目（胖子-瘦子）
        regressionCount: 0 // 回视次数
      }
    };

    /* ==== GitHub API 中转配置 ==== */
    const API_BASE_URL = 'https://ok.edemi-lab.online/api/gh-eye';

    /* 初始化 jsPsych */
    const jsPsych = initJsPsych({
      display_element: 'jspsych-target',
      extensions: [
        {
          type: jsPsychExtensionWebgazer,
          params: {
            capture_events: ['gaze'], // 捕获眼动事件
            sampling_rate: 50 // 每秒采样50次
          }
        }
      ],
      on_trial_finish: function(data) {
        // 在每个试次结束时记录额外信息
        if (data.task === 'view') {
          console.log(`试次 ${data.trial_index} 完成:`, data);
        }
      },
      on_finish: function() {
        // 实验结束时停止音乐
        if (window.globalAudio && !window.globalAudio.paused) {
          window.globalAudio.pause();
        }
      }
    });

    /* ==== 状态更新函数 ==== */
    function updateInitStatus(field, value, isError = false) {
      const element = document.getElementById(`status-${field}`);
      if (element) {
        element.textContent = value;
        element.className = isError ? 'status-error' : 'status-value';
      }
    }

    // 显示/隐藏调试信息
    document.getElementById('debug-toggle').addEventListener('click', function() {
      const panel = document.getElementById('debug-panel');
      if (panel.style.display === 'block') {
        panel.style.display = 'none';
        this.textContent = '显示调试信息';
      } else {
        panel.style.display = 'block';
        this.textContent = '隐藏调试信息';
      }
    });

    // 更新调试信息
    function updateDebugInfo(trial, dataPoints, leftDwell, rightDwell, firstFixation, regressions) {
      document.getElementById('debug-trial').textContent = trial;
      document.getElementById('debug-data-points').textContent = dataPoints;
      document.getElementById('debug-left-gaze').textContent = `${leftDwell}ms`;
      document.getElementById('debug-right-gaze').textContent = `${rightDwell}ms`;
      document.getElementById('debug-first-fixation').textContent = firstFixation;
      document.getElementById('debug-regressions').textContent = regressions;
    }

    /* ==== 人脸检测函数 ==== */
    async function checkFaceDetection() {
      updateInitStatus('face', '检测中...');

      return new Promise((resolve) => {
        let detected = false;
        let attempts = 0;
        const maxAttempts = 10;

        const checkInterval = setInterval(() => {
          attempts++;

          if (webgazer && webgazer.getTracker()) {
            const tracker = webgazer.getTracker();
            if (tracker.isUserVisible()) {
              detected = true;
              clearInterval(checkInterval);
              updateInitStatus('face', '检测成功');
              resolve(true);
            }
          }

          if (attempts >= maxAttempts) {
            clearInterval(checkInterval);
            updateInitStatus('face', '检测失败', true);
            resolve(false);
          }
        }, 500);
      });
    }

    // 显示人脸检测帮助
    function showFaceDetectionHelp() {
      const helpEl = document.getElementById('face-detection-help');
      helpEl.style.display = 'block';

      // 尝试显示摄像头预览
      if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
        navigator.mediaDevices.getUserMedia({ video: true })
          .then(stream => {
            const previewEl = document.getElementById('camera-preview');
            previewEl.innerHTML = '';
            const video = document.createElement('video');
            video.srcObject = stream;
            video.autoplay = true;
            video.playsInline = true;
            previewEl.appendChild(video);
          })
          .catch(err => {
            console.error('无法访问摄像头:', err);
          });
      }

      // 重试按钮事件
      document.getElementById('retry-face-detection').addEventListener('click', async () => {
        helpEl.style.display = 'none';
        faceDetectionAttempts++;

        // 最多尝试3次
        if (faceDetectionAttempts <= 3) {
          const detected = await checkFaceDetection();
          if (detected) {
            // 继续实验
            if (window.resumeExperiment) {
              window.resumeExperiment();
            }
          } else {
            // 再次显示帮助
            showFaceDetectionHelp();
          }
        } else {
          // 超过最大尝试次数，跳过眼动追踪
          cameraPermissionDenied = true;
          if (window.resumeExperiment) {
            window.resumeExperiment();
          }
        }
      });
    }

    /* ==== 摄像头权限检测和错误处理函数 ==== */
    async function checkCameraPermission() {
      // 更新状态
      updateInitStatus('camera', '检测中...');
      updateInitStatus('permission', '检测中...');
      updateInitStatus('security', '检测中...');

      // 1. 检查是否在安全环境（HTTPS或localhost）
      const isSecure = location.protocol === 'https:' || location.hostname === 'localhost';
      updateInitStatus('security', isSecure ? '安全' : '不安全', !isSecure);

      // 2. 检查浏览器是否支持媒体设备
      const hasMediaDevices = 'mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices;
      updateInitStatus('camera', hasMediaDevices ? '支持' : '不支持', !hasMediaDevices);

      // 3. 尝试获取摄像头权限
      let hasPermission = false;
      try {
        if (hasMediaDevices) {
          const stream = await navigator.mediaDevices.getUserMedia({ video: true });
          hasPermission = true;
          // 关闭测试流
          stream.getTracks().forEach(track => track.stop());
        }
      } catch (error) {
        console.error('摄像头权限检测失败:', error);
        updateInitStatus('error', error.message || error.toString(), true);
      }

      updateInitStatus('permission', hasPermission ? '已授予' : '未授予', !hasPermission);

      return {
        hasPermission,
        isSecure,
        hasMediaDevices
      };
    }

    function showPermissionError(status) {
      const alertEl = document.getElementById('camera-permission-alert');

      let alertHTML = `
        <h3>摄像头权限问题</h3>
        ${!status.hasMediaDevices ? `
          <div class="browser-warning">
            <p class="warning">您的浏览器不支持摄像头功能</p>
            <p>请使用最新版本的Chrome、Firefox或Edge浏览器参与实验。</p>
          </div>
        ` : ''}

        ${!status.isSecure ? `
          <div class="protocol-warning">
            <p class="warning">当前环境不安全</p>
            <p>摄像头功能需要HTTPS安全连接或本地环境(localhost)。</p>
            <p>当前协议: ${location.protocol}</p>
          </div>
        ` : ''}

        ${status.hasMediaDevices && status.isSecure && !status.hasPermission ? `
          <p>实验需要使用您的摄像头进行眼动追踪。</p>
          <p>您尚未授予摄像头权限或权限已被拒绝。</p>
          <div class="instructions">
            <p class="warning">请按照以下步骤操作:</p>
            <ol>
              <li>点击浏览器地址栏左侧的摄像头图标</li>
              <li>选择"始终允许此网站使用摄像头"</li>
              <li>刷新页面</li>
            </ol>
          </div>
        ` : ''}

        <div style="margin-top: 20px; display: flex; gap: 10px; justify-content: center;">
          <button id="reload-btn" class="auth-confirm auth-button">刷新页面</button>
          <button id="continue-btn" class="auth-cancel auth-button">继续实验(无眼动)</button>
        </div>
      `;

      alertEl.innerHTML = alertHTML;
      alertEl.style.display = 'block';

      // 添加事件处理
      document.getElementById('reload-btn').addEventListener('click', () => {
        location.reload();
      });

      document.getElementById('continue-btn').addEventListener('click', function() {
        alertEl.style.display = 'none';
        // 设置标志允许实验继续（无眼动功能）
        cameraPermissionDenied = true;
        // 继续执行实验流程
        if (window.resumeExperiment) {
          window.resumeExperiment();
        }
      });
    }

    /* ==== 眼动数据分析函数 ==== */
    // 判断注视点所在的区域
    function getGazeRegion(x, y) {
      if (!containerRect) {
        console.error('容器位置信息未设置');
        return 'outside';
      }

      // 检查是否在容器内
      if (x < containerRect.left || x > containerRect.right ||
          y < containerRect.top || y > containerRect.bottom) {
        return 'outside';
      }

      // 计算相对位置
      const relativeX = x - containerRect.left;
      const containerWidth = containerRect.right - containerRect.left;

      // 判断左右区域
      if (relativeX < containerWidth / 2) {
        return 'left';
      } else {
        return 'right';
      }
    }

    // 分析眼动数据
    function analyzeGazeData(gazeData, imageType, imageAttribute) {
      let leftDwellTime = 0;
      let rightDwellTime = 0;
      let firstFixation = null;
      let regressions = 0;

      // 计算注视时间
      gazeData.forEach(gaze => {
        const region = getGazeRegion(gaze.x, gaze.y);
        if (region === 'left') {
          leftDwellTime += 20; // 每20ms一个采样点
        } else if (region === 'right') {
          rightDwellTime += 20;
        }
      });

      // 计算首视点
      if (gazeData.length > 0) {
        const firstRegion = getGazeRegion(gazeData[0].x, gazeData[0].y);
        firstFixation = firstRegion;
      }

      // 计算回视次数
      let lastRegion = null;
      let lastTransitionTime = null;

      gazeData.forEach((gaze, index) => {
        const currentRegion = getGazeRegion(gaze.x, gaze.y);

        // 检测区域变化
        if (lastRegion && currentRegion !== lastRegion && currentRegion !== 'outside') {
          // 检查是否是回视（快速回到之前的区域）
          if (lastTransitionTime && (gaze.timestamp - lastTransitionTime) < 500) {
            regressions++;
          }
          lastTransitionTime = gaze.timestamp;
        }

        lastRegion = currentRegion;
      });

      // 根据图片类型和属性计算最终指标
      let result = {};

      if (imageType === 'food') {
        // 食物图片：前8张是低热量在左边，后12张是高热量在左边
        const isLowCalorieLeft = parseInt(imageAttribute.split('_')[0]) <= 8;

        if (isLowCalorieLeft) {
          // 左边是低热量，右边是高热量
          result.dwellTime = rightDwellTime - leftDwellTime; // 高热量-低热量
          result.firstFixation = firstFixation === 'right' ? 1 : (firstFixation === 'left' ? -1 : 0);
        } else {
          // 左边是高热量，右边是低热量
          result.dwellTime = leftDwellTime - rightDwellTime; // 高热量-低热量
          result.firstFixation = firstFixation === 'left' ? 1 : (firstFixation === 'right' ? -1 : 0);
        }
      } else if (imageType === 'body') {
        // 身材图片：前11张是胖子在左边，后14张是瘦子在左边
        const isFatLeft = parseInt(imageAttribute.split('_')[0]) <= 11;

        if (isFatLeft) {
          // 左边是胖子，右边是瘦子
          result.dwellTime = leftDwellTime - rightDwellTime; // 胖子-瘦子
          result.firstFixation = firstFixation === 'left' ? 1 : (firstFixation === 'right' ? -1 : 0);
        } else {
          // 左边是瘦子，右边是胖子
          result.dwellTime = rightDwellTime - leftDwellTime; // 胖子-瘦子
          result.firstFixation = firstFixation === 'right' ? 1 : (firstFixation === 'left' ? -1 : 0);
        }
      }

      result.regressionCount = regressions;
      result.leftDwellTime = leftDwellTime;
      result.rightDwellTime = rightDwellTime;

      // 更新调试信息
      updateDebugInfo(
        `${imageType}-${imageAttribute}`,
        gazeData.length,
        leftDwellTime,
        rightDwellTime,
        firstFixation,
        regressions
      );

      return result;
    }

  // 修改汇总分析结果的函数
function aggregateResults(trialData) {
    const foodTrials = trialData.filter(trial => trial.image_type === 'food');
    const bodyTrials = trialData.filter(trial => trial.image_type === 'body');

    // 计算食物图片的平均值
    if (foodTrials.length > 0) {
        analysisResults.food.dwellTime = foodTrials.reduce((sum, trial) =>
            sum + ((trial.analysisResult && trial.analysisResult.dwellTime) || 0), 0) / foodTrials.length;
        analysisResults.food.firstFixation = foodTrials.reduce((sum, trial) =>
            sum + ((trial.analysisResult && trial.analysisResult.firstFixation) || 0), 0);
        analysisResults.food.regressionCount = foodTrials.reduce((sum, trial) =>
            sum + ((trial.analysisResult && trial.analysisResult.regressionCount) || 0), 0) / foodTrials.length;
    }

    // 计算身材图片的平均值
    if (bodyTrials.length > 0) {
        analysisResults.body.dwellTime = bodyTrials.reduce((sum, trial) =>
            sum + ((trial.analysisResult && trial.analysisResult.dwellTime) || 0), 0) / bodyTrials.length;
        analysisResults.body.firstFixation = bodyTrials.reduce((sum, trial) =>
            sum + ((trial.analysisResult && trial.analysisResult.firstFixation) || 0), 0);
        analysisResults.body.regressionCount = bodyTrials.reduce((sum, trial) =>
            sum + ((trial.analysisResult && trial.analysisResult.regressionCount) || 0), 0) / bodyTrials.length;
    }

    // 添加调试信息
    console.log('分析结果汇总:', analysisResults);
    console.log('特征值对应:');
    console.log('b首视点 (body.firstFixation):', analysisResults.body.firstFixation);
    console.log('b回视次数 (body.regressionCount):', analysisResults.body.regressionCount);
    console.log('b注视时长 (body.dwellTime):', analysisResults.body.dwellTime);
    console.log('f首视点 (food.firstFixation):', analysisResults.food.firstFixation);
    console.log('f回视次数 (food.regressionCount):', analysisResults.food.regressionCount);
    console.log('f注视时长 (food.dwellTime):', analysisResults.food.dwellTime);
}

  // 生成结果表格
function generateResultsTable(predictionResult = null) {
    let tableContent = `
        <table class="results-table">
            <thead>
                <tr>
                    <th>被试编号</th>
                    <th>F注视时间(ms)</th>
                    <th>B注视时间(ms)</th>
                    <th>F首视点</th>
                    <th>B首视点</th>
                    <th>F回视次数</th>
                    <th>B回视次数</th>
    `;

    // 添加预测结果列
    if (predictionResult) {
        tableContent += `
                    <th>预测结果</th>
        `;
    }

    tableContent += `
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td>${userInfo.subjectId}</td>
                    <td>${analysisResults.food.dwellTime.toFixed(2)}</td>
                    <td>${analysisResults.body.dwellTime.toFixed(2)}</td>
                    <td>${analysisResults.food.firstFixation}</td>
                    <td>${analysisResults.body.firstFixation}</td>
                    <td>${analysisResults.food.regressionCount.toFixed(2)}</td>
                    <td>${analysisResults.body.regressionCount.toFixed(2)}</td>
    `;

    // 添加预测结果数据
    if (predictionResult) {
        const resultText = predictionResult.predictedClass === 1 ? '不正常' : '正常';
        tableContent += `
                    <td>${resultText}</td>
        `;
    }

    tableContent += `
                </tr>
            </tbody>
        </table>
    `;

    return tableContent;
}
// 生成CSV格式的结果
function generateResultsCSV(predictionResult = null) {
  let csvHeader = '被试编号,F注视时间(ms),B注视时间(ms),F首视点,B首视点,F回视次数,B回视次数';
  let csvData = `${userInfo.subjectId},${analysisResults.food.dwellTime.toFixed(2)},${analysisResults.body.dwellTime.toFixed(2)},${analysisResults.food.firstFixation},${analysisResults.body.firstFixation},${analysisResults.food.regressionCount.toFixed(2)},${analysisResults.body.regressionCount.toFixed(2)}`;

  // 如果有预测结果，只添加预测结果，删除置信度和风险等级
  if (predictionResult) {
    const resultText = predictionResult.predictedClass === 1 ? '不正常' : '正常';
    csvHeader += ',预测结果';
    csvData += `,${resultText}`;
  }

  return `${csvHeader}\n${csvData}`;
}

/* ==== ONNX模型功能 ==== */
async function loadModel() {
    try {
        console.log('开始加载模型...');

        // 加载预处理配置
        const configResponse = await fetch('preprocessing.json');
        if (!configResponse.ok) {
            throw new Error(`预处理配置加载失败: ${configResponse.status}`);
        }
        preprocessingConfig = await configResponse.json();
        console.log('预处理配置加载成功:', preprocessingConfig);

        // 加载ONNX模型
        onnxSession = await ort.InferenceSession.create('model.onnx');
        console.log('ONNX模型加载成功');

        modelLoaded = true;
        return true;
    } catch (error) {
        console.error('模型加载失败:', error);
        modelLoaded = false;
        return false;
    }
}

// 特征映射函数 - 将HTML数据转换为模型输入
function prepareModelInput(analysisResults) {
    // 根据预处理配置中的特征顺序准备输入
    const featureValues = [];

    // 特征顺序: ['b首视点', 'b回视次数', 'b注视时长', 'f首视点', 'f回视次数', 'f注视时长']
    featureValues.push(analysisResults.body.firstFixation);    // b首视点
    featureValues.push(analysisResults.body.regressionCount);  // b回视次数
    featureValues.push(analysisResults.body.dwellTime);        // b注视时长
    featureValues.push(analysisResults.food.firstFixation);    // f首视点
    featureValues.push(analysisResults.food.regressionCount);  // f回视次数
    featureValues.push(analysisResults.food.dwellTime);        // f注视时长

    console.log('原始特征值:', featureValues);

    // 标准化处理
    const standardizedFeatures = featureValues.map((value, index) => {
        const mean = preprocessingConfig.mean[index];
        const scale = preprocessingConfig.scale[index];
        return (value - mean) / scale;
    });

    console.log('标准化后特征值:', standardizedFeatures);

    return standardizedFeatures;
}

// 使用模型进行预测
async function predictEatingDisorder(analysisResults) {
    if (!modelLoaded || !onnxSession) {
        console.error('模型未加载，无法进行预测');
        return {
            predictedClass: -1,
            confidence: 0,
            riskLevel: '未知',
            error: '模型未加载'
        };
    }

    try {
        // 准备输入数据
        const inputData = prepareModelInput(analysisResults);

        // 创建ONNX输入张量
        const inputTensor = new ort.Tensor('float32', Float32Array.from(inputData), [1, 6]);

        // 运行预测
        const results = await onnxSession.run({ 'float_input': inputTensor });

        // 获取预测结果
        const output = results.output.data;
        console.log('模型输出:', output);

        // 解析预测结果
        return {
            probabilities: Array.from(output),
            predictedClass: output[1] > 0.5 ? 1 : 0,
            confidence: Math.max(...output) * 100,
            riskLevel: output[1] > 0.7 ? '高风险' : output[1] > 0.4 ? '中等风险' : '低风险'
        };

    } catch (error) {
        console.error('预测失败:', error);
        return {
            predictedClass: -1,
            confidence: 0,
            riskLevel: '未知',
            error: error.message
        };
    }
}
    /* ==== GitHub API 功能 ==== */

    // 创建或获取Issue（带错误处理和重试机制） - 总共尝试2次
    async function getOrCreateIssue(retries = 1) {
      const issueTitle = `${userInfo.subjectId}`;

      try {
        // 使用AbortController实现超时
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);

        const response = await fetch(API_BASE_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'create_issue',
            subjectId: userInfo.subjectId,
            gender: userInfo.gender,
            age: userInfo.age
          }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          const errorData = await response.json();
          console.error('GitHub API错误详情:', errorData);
          let errorMsg = `中转API返回错误: ${response.status}`;
          if (errorData && errorData.error) {
            errorMsg = errorData.error;
            if (errorData.message) {
              errorMsg += `: ${errorData.message}`;
            }
          }
          throw new Error(errorMsg);
        }

        return await response.json();
      } catch (error) {
        console.error(`GitHub Issue操作失败(剩余重试次数: ${retries-1}):`, error);

        // 如果还有重试次数，等待后重试
        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 2000));
          return getOrCreateIssue(retries - 1);
        }

        throw error;
      }
    }

    // 添加单条Issue评论 - 修改：重试次数改为1（即总共尝试2次）
    async function addIssueComment(issueNumber, commentBody, retries = 1) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 10000);

        const response = await fetch(API_BASE_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'add_comment',
            issueNumber: issueNumber,
            commentBody: commentBody
          }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          const errorData = await response.json();
          console.error('添加评论错误详情:', errorData);
          let errorMsg = `中转API返回错误: ${response.status}`;
          if (errorData && errorData.error) {
            errorMsg = errorData.error;
            if (errorData.message) {
              errorMsg += `: ${errorData.message}`;
            }
          }
          throw new Error(errorMsg);
        }

        return await response.json();
      } catch (error) {
        console.error(`添加评论失败(剩余重试次数: ${retries-1}):`, error);

        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 2000));
          return addIssueComment(issueNumber, commentBody, retries - 1);
        }

        throw error;
      }
    }

    // 上传文件到GitHub仓库（支持分块上传）
    async function uploadFileToGitHub(content, fileName, directory, retries = 1) {
      const MAX_FILE_SIZE = 700 * 1024; // 700KB
      const encoder = new TextEncoder();
      const fileData = encoder.encode(content);
      const totalSize = fileData.length;

      try {
        // 解析文件名和后缀
        const lastDotIndex = fileName.lastIndexOf('.');
        let baseName, extension;
        if (lastDotIndex === -1) {
          baseName = fileName;
          extension = '';
        } else {
          baseName = fileName.substring(0, lastDotIndex);
          extension = fileName.substring(lastDotIndex + 1);
        }

        // 如果文件小于最大限制，直接上传
        if (totalSize <= MAX_FILE_SIZE) {
          return await uploadFilePart(content, `${directory}/${fileName}`, retries);
        }

        // 分割文件
        let uploadPromises = [];
        let partIndex = 1;
        let startIndex = 0;

        while (startIndex < totalSize) {
          // 计算结束位置（尝试在换行符处分割）
          let endIndex = Math.min(startIndex + MAX_FILE_SIZE, totalSize);

          // 查找最近的换行符
          while (endIndex < totalSize && fileData[endIndex] !== 10) { // 10是换行符的ASCII
            endIndex++;
          }

          // 如果找不到换行符，使用最大位置
          if (endIndex >= totalSize) {
            endIndex = totalSize;
          }

          // 提取当前部分
          const partData = fileData.slice(startIndex, endIndex);
          const partContent = new TextDecoder().decode(partData);

          // 生成文件名（添加分块编号）
          const newFileName = extension ? `${baseName}_part${partIndex}.${extension}` : `${baseName}_part${partIndex}`;
          const partFileName = `${directory}/${newFileName}`;

          // 上传分块
          uploadPromises.push(uploadFilePart(partContent, partFileName, retries));

          // 移动到下一部分
          startIndex = endIndex;
          partIndex++;
        }

        // 等待所有上传完成
        return await Promise.all(uploadPromises);
      } catch (error) {
        console.error(`文件上传失败(剩余重试次数: ${retries-1}):`, error);

        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 2000));
          return uploadFileToGitHub(content, fileName, directory, retries - 1);
        }

        throw error;
      }
    }

    // 上传单个文件分块到GitHub - 总共尝试2次
    async function uploadFilePart(content, fileName, retries = 1) {
      try {
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 20000); // 延长超时时间到20秒

        const response = await fetch(API_BASE_URL, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            action: 'upload_file',
            fileName: fileName,
            content: content,
            directory: fileName.includes('/') ? fileName.substring(0, fileName.lastIndexOf('/')) : ''
          }),
          signal: controller.signal
        });

        clearTimeout(timeoutId);

        if (!response.ok) {
          // 尝试解析错误信息
          let errorMsg = `文件上传失败: ${response.status}`;
          try {
            const errorData = await response.json();
            if (errorData && errorData.error) {
              errorMsg = errorData.error;
              if (errorData.message) {
                errorMsg += `: ${errorData.message}`;
              }
            }
          } catch (e) {
            // 如果解析失败，保持原错误信息
            console.error('解析错误响应失败', e);
            errorMsg = `文件上传失败: ${response.status} ${response.statusText}`;
          }
          throw new Error(errorMsg);
        }

        return await response.json();
      } catch (error) {
        console.error(`文件分块上传失败(剩余重试次数: ${retries-1}):`, error);

        if (retries > 0) {
          await new Promise(resolve => setTimeout(resolve, 2000));
          return uploadFilePart(content, fileName, retries - 1);
        }

        throw error;
      }
    }

    // 生成GitHub评论内容（包含分析结果和预测）
function generateGitHubComment(dataPoints, predictionResult = null) {
    const now = new Date();
    const dateTime = `${now.getFullYear()}年${(now.getMonth()+1).toString().padStart(2, '0')}月${now.getDate().toString().padStart(2, '0')}日 ${now.getHours().toString().padStart(2, '0')}:${now.getMinutes().toString().padStart(2, '0')}:${now.getSeconds().toString().padStart(2, '0')}`;

    let comment = `## 第 ${userInfo.session} 次实验数据\n\n` +
           `- **实验日期时间**: ${dateTime}\n` +
           `- **眼动数据点总数**: ${dataPoints}\n` +
           `- **F注视时间**: ${analysisResults.food.dwellTime.toFixed(2)}ms\n` +
           `- **B注视时间**: ${analysisResults.body.dwellTime.toFixed(2)}ms\n` +
           `- **F首视点**: ${analysisResults.food.firstFixation}\n` +
           `- **B首视点**: ${analysisResults.body.firstFixation}\n` +
           `- **F回视次数**: ${analysisResults.food.regressionCount.toFixed(2)}\n` +
           `- **B回视次数**: ${analysisResults.body.regressionCount.toFixed(2)}\n`;

    // 添加预测结果
    if (predictionResult) {
        const resultText = predictionResult.predictedClass === 1 ? '不正常' : '正常';
        comment += `- **AI预测结果**: ${resultText}\n`;
    }

    return comment;
}

    // 保存CSV到本地
    function saveCSVToLocal(csvContent, fileName) {
      const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    // 保存JSON到本地
    function saveJSONToLocal(jsonContent, fileName) {
      const blob = new Blob([jsonContent], { type: 'application/json;charset=utf-8' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = fileName;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
    }

    /* 生成图片列表 */
    // 食物图片：f文件夹（共20张）
    // 前8张：左侧低热量；后12张：左侧高热量
    const foodImages = [];
    const totalFood = 20;
    const lowCalorieCount = 8; // 前8张为左侧低热量
    for (let i = 1; i <= totalFood; i++) {
      const isLowCalorie = i <= lowCalorieCount;
      foodImages.push({
        src: `f/${i}.jpg`, // 图片路径：f文件夹下
        type: 'food',
        attribute: `${i}_${isLowCalorie ? 'low_calorie' : 'high_calorie'}`, // 标记高低热量和序号
        position: 'left', // 左侧为目标属性（低/高热量）
        index: i // 原始序号
      });
    }

    // 身材图片：b文件夹（共25张）
    // 前11张：左侧胖；后14张：左侧瘦
    const bodyImages = [];
    const totalBody = 25;
    const fatCount = 11; // 前11张为左侧胖
    for (let i = 1; i <= totalBody; i++) {
      const isFat = i <= fatCount;
      bodyImages.push({
        src: `b/${i}.jpg`, // 图片路径：b文件夹下
        type: 'body',
        attribute: `${i}_${isFat ? 'fat' : 'thin'}`, // 标记胖/瘦和序号
        position: 'left', // 左侧为目标属性（胖/瘦）
        index: i // 原始序号
      });
    }

    /* ==== 用户登录页面 ==== */
    const loginScreen = {
      type: jsPsychHtmlButtonResponse,
      stimulus: function() {
        // 获取当前被试的次数信息
        let sessionInfo = "";
        const subjectIdEl = document.getElementById('subject-id');
        if (subjectIdEl && subjectIdEl.value) {
          const subjectId = subjectIdEl.value;
          const storedSession = localStorage.getItem(`session_${subjectId}`);
          const currentSession = storedSession ? parseInt(storedSession) + 1 : 1;
          sessionInfo = `<div class="session-display">这是您的第 <span>${currentSession}</span> 次实验</div>`;
        }

        return `
          <div class="login-container">
            <h2>实验用户登录</h2>
            <div class="form-group">
              <label for="subject-id">被试ID</label>
              <select id="subject-id">
                <option value="">请选择被试ID</option>
                ${Array.from({length: 151}, (_, i) => {
                  const id = `eye-${(i+1).toString().padStart(3, '0')}`;
                  return `<option value="${id}">${id}</option>`;
                }).join('')}
              </select>
            </div>
            ${sessionInfo}
            <div class="form-group">
              <label for="gender">性别</label>
              <select id="gender">
                <option value="">请选择性别</option>
                <option value="男">男</option>
                <option value="女">女</option>
                <option value="其他">其他</option>
              </select>
            </div>
            <div class="form-group">
              <label for="age">年龄</label>
              <input type="number" id="age" min="18" max="60" placeholder="请输入年龄">
            </div>
            <button class="login-button" id="login-btn">开始实验</button>
            <div id="login-status" style="margin-top: 15px;"></div>
          </div>
        `;
      },
      choices: [],
      on_load: function() {
        // 监听被试ID变化，更新次数显示并自动填充用户信息
        document.getElementById('subject-id').addEventListener('change', function() {
          const subjectId = this.value;
          if (subjectId) {
            const storedSession = localStorage.getItem(`session_${subjectId}`);
            const currentSession = storedSession ? parseInt(storedSession) + 1 : 1;

            // 创建或更新次数显示
            let sessionDisplay = document.querySelector('.session-display');
            if (!sessionDisplay) {
              sessionDisplay = document.createElement('div');
              sessionDisplay.className = 'session-display';
              document.querySelector('.login-container').insertBefore(sessionDisplay, document.querySelector('.form-group:last-child'));
            }
            sessionDisplay.innerHTML = `这是您的第 <span>${currentSession}</span> 次实验`;

            // 尝试获取存储的用户信息并自动填充
            const userData = localStorage.getItem(`user_${subjectId}`);
            if (userData) {
              try {
                const { gender, age } = JSON.parse(userData);
                document.getElementById('gender').value = gender;
                document.getElementById('age').value = age;
              } catch (e) {
                console.error('解析用户信息失败', e);
              }
            }
          }
        });

        document.getElementById('login-btn').addEventListener('click', function() {
          const subjectId = document.getElementById('subject-id').value;
          const gender = document.getElementById('gender').value;
          const age = document.getElementById('age').value;
          const statusEl = document.getElementById('login-status');

          if (!subjectId) {
            statusEl.innerHTML = '<p style="color: #e74c3c;">请选择被试ID</p>';
            return;
          }
          if (!gender) {
            statusEl.innerHTML = '<p style="color: #e74c3c;">请选择性别</p>';
            return;
          }
          if (!age) {
            statusEl.innerHTML = '<p style="color: #e74c3c;">请输入年龄</p>';
            return;
          }

          // 从localStorage获取当前次数
          const storedSession = localStorage.getItem(`session_${subjectId}`);
          const session = storedSession ? parseInt(storedSession) + 1 : 1;

          // 保存用户信息
          userInfo = {
            subjectId,
            session,
            gender,
            age: parseInt(age)
          };

          // 存储用户信息（性别和年龄）
          localStorage.setItem(`user_${subjectId}`, JSON.stringify({ gender, age }));

          // 显示成功信息
          statusEl.innerHTML = '<p style="color: #27ae60;">验证通过，正在进入实验...</p>';

          // 继续实验流程
          setTimeout(() => {
            jsPsych.finishTrial();
          }, 1000);
        });
      }
    };

    const timeline = [];
    timeline.push(loginScreen);

    // 显示欢迎信息
    timeline.push({
      type: jsPsychHtmlKeyboardResponse,
      stimulus: function() {
        if (!userInfo) {
          return `
            <div class="centered-text">
              <p>欢迎参与实验</p>
              <p>按任意键继续</p>
            </div>
          `;
        }
        return `
          <div class="centered-text">
            <p>欢迎您参与第 ${userInfo.session} 次实验</p>
            <p>按任意键继续</p>
          </div>
        `;
      }
    });

    /* 预加载资源 */
    const allImages = [...foodImages, ...bodyImages].map(img => img.src);
    const preload = {
      type: jsPsychPreload,
      images: allImages,
      message: '<div class="centered-text><p>正在加载资源，请稍候…</p></div>',
      on_error: function(failed_resources) {
        const resources = Array.isArray(failed_resources) ? failed_resources : [failed_resources];
        const errorList = resources.map(r => `<p>• 资源加载失败: ${r.url || r}</p>`).join('');
        return `<div class="centered-text">
          <p style="color: #e74c3c; font-weight: bold;">资源加载错误：</p>
          ${errorList}
          <p>请检查文件是否存在于正确路径</p>
        </div>`;
      }
    };
    timeline.push(preload);

    /* ==== 校准相关的各个步骤 ==== */
    const camera_instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="centered-text">
          <p>为了进行眼动追踪，我们需要访问您的摄像头。</p>
          <p>您将在下一屏幕收到权限请求。</p>
          <p class="warning">请务必点击"允许"，否则眼动追踪功能将无法工作。</p>
          <p>摄像头仅用于分析您的眼部运动，不会保存任何视频数据。</p>
        </div>
      `,
      choices: ['明白了'],
      on_load: async function() {
        // 提前检测权限
        const cameraStatus = await checkCameraPermission();

        // 如果权限有问题，显示错误提示
        if (!cameraStatus.hasPermission || !cameraStatus.isSecure || !cameraStatus.hasMediaDevices) {
          showPermissionError(cameraStatus);

          // 保存继续实验的函数
          window.resumeExperiment = () => {
            jsPsych.finishTrial();
          };

          // 暂停实验直到用户操作
          return false;
        }
      }
    };
    timeline.push(camera_instructions);

    // 初始化摄像头（显示画面）
    const init_camera = {
      type: jsPsychWebgazerInitCamera,
      on_error: function() {
        cameraPermissionDenied = true;
        updateInitStatus('webgazer', '初始化失败', true);
      },
      on_load: function() {
        updateInitStatus('webgazer', '初始化中...');
      },
      on_finish: function() {
        if (!cameraPermissionDenied) {
          updateInitStatus('webgazer', '已初始化');
          webgazerInitialized = true;

          // 添加人脸检测
          setTimeout(async () => {
            const faceDetected = await checkFaceDetection();
            if (!faceDetected) {
              showFaceDetectionHelp();

              // 暂停实验直到用户操作
              return false;
            }
          }, 1000);
        }
      }
    };
    timeline.push(init_camera);

    // 添加权限检查点
    timeline.push({
      type: jsPsychHtmlButtonResponse,
      stimulus: '',
      choices: [],
      trial_duration: 100,
      on_load: function() {
        // 如果权限被拒绝，跳过眼动相关步骤
        if (cameraPermissionDenied) {
          // 直接跳转到实验说明
          jsPsych.endCurrentTimeline();

          // 显示警告
          const warningHTML = `
            <div class="centered-text">
              <p class="warning">警告：摄像头权限未授予</p>
              <p>眼动追踪功能已被禁用，实验将继续进行但不会记录眼动数据。</p>
              <p>按任意键继续实验。</p>
            </div>
          `;

          const warningTrial = {
            type: jsPsychHtmlKeyboardResponse,
            stimulus: warningHTML
          };

          jsPsych.addNodeToEndOfTimeline(warningTrial);
        }
      }
    });

    const calibration_instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="centered-text">
          <p>现在将进行眼动校准，以便软件使用您的眼部图像预测您的注视位置。</p>
          <p>您将看到一系列圆点出现在屏幕上。请注视每个圆点并点击它。</p>
          <p style="color: red; font-weight: bold;">请确保：</p>
          <ul style="text-align: left; max-width: 600px; margin: 0 auto;">
            <li>您的脸部在摄像头画面中</li>
            <li>光线充足，不要过暗或过亮</li>
            <li>避免晃动头部</li>
          </ul>
        </div>
      `,
      choices: ['明白了']
    };
    timeline.push(calibration_instructions);

    const calibration = {
      type: jsPsychWebgazerCalibrate,
      calibration_points: [
        [25, 25], [75, 25], [50, 50], [25, 75], [75, 75]
      ],
      repetitions_per_point: 2,
      randomize_calibration_order: true
    };
    timeline.push(calibration);

    const validation_instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="centered-text">
          <p>现在我们将测量校准的准确性。</p>
          <p>请注视屏幕上出现的每个圆点。</p>
          <p style="font-weight: bold;">这次您不需要点击圆点。</p>
        </div>
      `,
      choices: ['明白了'],
      post_trial_gap: 1000
    };
    timeline.push(validation_instructions);

    const validation = {
      type: jsPsychWebgazerValidate,
      validation_points: [
        [25, 25], [75, 25], [50, 50], [25, 75], [75, 75]
      ],
      roi_radius: 200,
      time_to_saccade: 1000,
      validation_duration: 2000,
      data: { task: 'validate' }
    };
    timeline.push(validation);

    const recalibrate_instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="centered-text">
          <p>校准的准确性低于预期水平。</p>
          <p>让我们再尝试校准一次。</p>
          <p>在下一屏幕，请注视圆点并点击它们。</p>
        </div>
      `,
      choices: ['好的']
    };
    const recalibrate = {
      timeline: [recalibrate_instructions, calibration, validation_instructions, validation],
      conditional_function: function() {
        const val_data = jsPsych.data.get().filter({ task: 'validate' }).values()[0];
        return val_data && val_data.percent_in_roi && val_data.percent_in_roi.some(x => x < 50);
      },
      data: { phase: 'recalibration' }
    };
    timeline.push(recalibrate);

    const calibration_done = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="centered-text">
          <p>太好了，校准已完成！</p>
          <p>接下来将开始实验，请注视屏幕中央的十字，然后观看图片。</p>
        </div>
      `,
      choices: ['继续']
    };
    timeline.push(calibration_done);

    /* ==== 欢迎页 和 实验说明 ==== */
    const welcome = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="centered-text">
          <p>欢迎参加进食障碍眼动程序。按任意键继续。</p>
        </div>
      `
    };
    timeline.push(welcome);

    const instructions = {
      type: jsPsychHtmlKeyboardResponse,
      stimulus: `
        <div class="centered-text">
          <p>在实验中，您将先后观看两类对比图片：食物图片和身材图片。</p>
          <p>食物图片展示左侧低热量/高热量食物的对比，身材图片展示左侧胖/瘦身材的对比。</p>
          <p>每张图片将呈现6秒，图片之间休息2秒。</p>
          <p>请按任意键开始实验。</p>
        </div>
      `,
      post_trial_gap: 2000
    };
    timeline.push(instructions);

    /* ==== 构建实验试次 ==== */
    // 1. 食物图片试次（随机呈现所有食物图片）
    const shuffledFoodImages = jsPsych.randomization.shuffle(foodImages); // 随机排序
    const foodTrials = [];

    // 2. 身材图片试次（随机呈现所有身材图片）
    const shuffledBodyImages = jsPsych.randomization.shuffle(bodyImages); // 随机排序
    const bodyTrials = [];

    const centralFixation = document.getElementById('central-fixation');
    const gazePoint = document.getElementById('gaze-point');

    // 开始眼动追踪并记录数据
    function startGazeTracking(trialData) {
      if (gazeUpdateInterval) clearInterval(gazeUpdateInterval);
      gazeData = []; // 重置眼动数据数组

      // 每20ms记录一次眼动数据（50Hz采样率）
      gazeUpdateInterval = setInterval(() => {
        if (webgazer) {
          webgazer.getCurrentPrediction().then(function(pred) {
            if (pred) {
              gazeData.push({
                timestamp: Date.now(),
                trial_start_time: trialData.trial_start_time,
                relative_time: Date.now() - trialData.trial_start_time,
                x: pred.x,
                y: pred.y,
                confidence: pred.confidence || null
              });
            }
          });
        }
      }, 20);
    }

    // 停止眼动追踪并保存数据
    function stopGazeTracking() {
      if (gazeUpdateInterval) {
        clearInterval(gazeUpdateInterval);
        gazeUpdateInterval = null;
      }
      gazePoint.style.display = 'none';
      return gazeData; // 返回收集的眼动数据
    }

    // 生成食物试次
    shuffledFoodImages.forEach((img, index) => {
      // 注视点试次
      foodTrials.push({
        type: jsPsychHtmlKeyboardResponse,
        stimulus: '',
        choices: "NO_KEYS",
        trial_duration: jsPsych.randomization.sampleWithoutReplacement([800, 1000, 1200], 1)[0],
        data: {
          task: 'fixation',
          phase: 'food',
          block: 'food_presentation',
          trial_index: index + 1,
          total_trials: shuffledFoodImages.length
        },
        on_start: function() {
          centralFixation.style.display = 'block';
        },
        on_finish: function() {
          centralFixation.style.display = 'none';
        }
      });

      // 图片展示试次
      const foodTrial = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: function() {
          return `
            <div class="stimulus-container">
              <div class="left-region"></div>
              <div class="right-region"></div>
              <img src="${img.src}" class="stimulus-image" alt="食物对比图片" />
            </div>
          `;
        },
        trial_duration: 6000,
        choices: "NO_KEYS",
        data: {
          task: 'view',
          phase: 'food',
          block: 'food_presentation',
          image_type: img.type,
          image_attribute: img.attribute,
          image_position: img.position,
          original_index: img.index,
          image_src: img.src,
          trial_index: index + 1,
          total_trials: shuffledFoodImages.length,
          trial_start_time: null, // 将在on_start中设置
          gaze_data: null,
          analysisResult: null // 存储分析结果
        },
        extensions: [
          {
            type: jsPsychExtensionWebgazer,
            params: { targets: ['.stimulus-container'] }
          }
        ],
        on_start: function(trial) {
          // 记录试次开始时间 - 修复点：直接存储到data对象
          const startTime = Date.now();
          trial.data.trial_start_time = startTime;
          // 在试次对象上存储开始时间
          this.trial_start_time = startTime;

          // 在图片加载完成后获取容器位置
          setTimeout(() => {
            const container = document.querySelector('.stimulus-container');
            if (container) {
              const rect = container.getBoundingClientRect();
              containerRect = {
                left: rect.left,
                right: rect.right,
                top: rect.top,
                bottom: rect.bottom
              };
              console.log('容器位置信息:', containerRect);
            }
          }, 500);

          startGazeTracking(trial.data);
        },
        on_finish: function(data) {
          // 确保开始时间被记录（使用试次对象上存储的开始时间）
          data.trial_start_time = this.trial_start_time;

          // 记录试次结束时间和眼动数据
          const endTime = Date.now();
          data.trial_end_time = endTime;

          // 确保有有效的开始时间
          const startTime = this.trial_start_time;
          if (startTime) {
            data.trial_duration_actual = endTime - startTime;
          } else {
            // 如果开始时间无效，使用眼动数据的第一条时间戳（如果有）
            if (gazeData.length > 0) {
              data.trial_start_time = gazeData[0].timestamp;
              data.trial_duration_actual = endTime - data.trial_start_time;
            } else {
              // 没有眼动数据，使用默认试次时长
              data.trial_duration_actual = 6000;
            }
          }

          data.gaze_data = stopGazeTracking(); // 保存眼动数据

          // 分析眼动数据
           if (data.gaze_data && data.gaze_data.length > 0) {
    data.analysisResult = analyzeGazeData(data.gaze_data, data.image_type, data.image_attribute);
    console.log(`试次 ${data.trial_index} 分析结果:`, data.analysisResult);
  } else {
    console.warn(`试次 ${data.trial_index} 无眼动数据`);
    // 添加这行代码，设置默认的analysisResult对象
    data.analysisResult = {
      dwellTime: 0,
      firstFixation: 0,
      regressionCount: 0,
      leftDwellTime: 0,
      rightDwellTime: 0
    };
  }
}
      };
      foodTrials.push(foodTrial);

      // 试次间休息（最后一个试次后不休息）
      if (index < shuffledFoodImages.length - 1) {
        foodTrials.push({
          type: jsPsychHtmlKeyboardResponse,
          stimulus: '',
          choices: "NO_KEYS",
          trial_duration: 2000,
          data: {
            task: 'rest',
            phase: 'food',
            block: 'food_presentation',
            trial_index: index + 1,
            total_trials: shuffledFoodImages.length
          }
        });
      }
    });

    // 阶段过渡提示（从食物到身材）
    const phaseTransition = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="centered-text">
          <p>食物图片观看完毕</p>
          <p>接下来将呈现身材对比图片</p>
        </div>
      `,
      choices: ['继续'],
      data: {
        task: 'transition',
        phase: 'between_blocks'
      }
    };

    /* ==== 在食物和身材图片之间插入第二个校准环节 ==== */
    const second_calibration_instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="centered-text">
          <p>现在将进行第二次眼动校准，以确保追踪准确性。</p>
          <p>您将看到一系列圆点出现在屏幕上。请注视每个圆点并点击它。</p>
        </div>
      `,
      choices: ['明白了']
    };

    const second_calibration = {
      type: jsPsychWebgazerCalibrate,
      calibration_points: [
        [25, 25], [75, 25], [50, 50], [25, 75], [75, 75]
      ],
      repetitions_per_point: 2,
      randomize_calibration_order: true
    };

    const second_validation_instructions = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="centered-text">
          <p>现在我们将测量第二次校准的准确性。</p>
          <p>请注视屏幕上出现的每个圆点。</p>
          <p style="font-weight: bold;">这次您不需要点击圆点。</p>
        </div>
      `,
      choices: ['明白了'],
      post_trial_gap: 1000
    };

    const second_validation = {
      type: jsPsychWebgazerValidate,
      validation_points: [
        [25, 25], [75, 25], [50, 50], [25, 75], [75, 75]
      ],
      roi_radius: 200,
      time_to_saccade: 1000,
      validation_duration: 2000,
      data: { task: 'validate_second' }
    };

    const second_recalibrate = {
      timeline: [second_calibration_instructions, second_calibration, second_validation_instructions, second_validation],
      conditional_function: function() {
        const val_data = jsPsych.data.get().filter({ task: 'validate_second' }).values()[0];
        return val_data && val_data.percent_in_roi && val_data.percent_in_roi.some(x => x < 50);
      },
      data: { phase: 'second_recalibration' }
    };

    const second_calibration_done = {
      type: jsPsychHtmlButtonResponse,
      stimulus: `
        <div class="centered-text">
          <p>第二次校准已完成！</p>
          <p>接下来将呈现身材对比图片，请注视屏幕中央的十字，然后观看图片。</p>
        </div>
      `,
      choices: ['继续']
    };

    // 生成身材试次
    shuffledBodyImages.forEach((img, index) => {
      // 注视点试次
      bodyTrials.push({
        type: jsPsychHtmlKeyboardResponse,
        stimulus: '',
        choices: "NO_KEYS",
        trial_duration: jsPsych.randomization.sampleWithoutReplacement([800, 1000, 1200], 1)[0],
        data: {
          task: 'fixation',
          phase: 'body',
          block: 'body_presentation',
          trial_index: index + 1,
          total_trials: shuffledBodyImages.length
        },
        on_start: function() {
          centralFixation.style.display = 'block';
        },
        on_finish: function() {
          centralFixation.style.display = 'none';
        }
      });

      // 图片展示试次
      const bodyTrial = {
        type: jsPsychHtmlKeyboardResponse,
        stimulus: function() {
          return `
            <div class="stimulus-container">
              <div class="left-region"></div>
              <div class="right-region"></div>
              <img src="${img.src}" class="stimulus-image" alt="身材对比图片" />
            </div>
          `;
        },
        trial_duration: 6000,
        choices: "NO_KEYS",
        data: {
          task: 'view',
          phase: 'body',
          block: 'body_presentation',
          image_type: img.type,
          image_attribute: img.attribute,
          image_position: img.position,
          original_index: img.index,
          image_src: img.src,
          trial_index: index + 1,
          total_trials: shuffledBodyImages.length,
          trial_start_time: null, // 将在on_start中设置
          gaze_data: null,
          analysisResult: null // 存储分析结果
        },
        extensions: [
          {
            type: jsPsychExtensionWebgazer,
            params: { targets: ['.stimulus-container'] }
          }
        ],
        on_start: function(trial) {
          // 记录试次开始时间 - 修复点：直接存储到data对象
          const startTime = Date.now();
          trial.data.trial_start_time = startTime;
          // 在试次对象上存储开始时间
          this.trial_start_time = startTime;

          // 在图片加载完成后获取容器位置
          setTimeout(() => {
            const container = document.querySelector('.stimulus-container');
            if (container) {
              const rect = container.getBoundingClientRect();
              containerRect = {
                left: rect.left,
                right: rect.right,
                top: rect.top,
                bottom: rect.bottom
              };
              console.log('容器位置信息:', containerRect);
            }
          }, 500);

          startGazeTracking(trial.data);
        },
        on_finish: function(data) {
          // 确保开始时间被记录（使用试次对象上存储的开始时间）
          data.trial_start_time = this.trial_start_time;

          // 记录试次结束时间和眼动数据
          const endTime = Date.now();
          data.trial_end_time = endTime;

          // 确保有有效的开始时间
          const startTime = this.trial_start_time;
          if (startTime) {
            data.trial_duration_actual = endTime - startTime;
          } else {
            // 如果开始时间无效，使用眼动数据的第一条时间戳（如果有）
            if (gazeData.length > 0) {
              data.trial_start_time = gazeData[0].timestamp;
              data.trial_duration_actual = endTime - data.trial_start_time;
            } else {
              // 没有眼动数据，使用默认试次时长
              data.trial_duration_actual = 6000;
            }
          }

          data.gaze_data = stopGazeTracking(); // 保存眼动数据

          // 分析眼动数据
          if (data.gaze_data && data.gaze_data.length > 0) {
            data.analysisResult = analyzeGazeData(data.gaze_data, data.image_type, data.image_attribute);
            console.log(`试次 ${data.trial_index} 分析结果:`, data.analysisResult);
          } else {
            console.warn(`试次 ${data.trial_index} 无眼动数据`);
          }
        }
      };
      bodyTrials.push(bodyTrial);

      // 试次间休息（最后一个试次后不休息）
      if (index < shuffledBodyImages.length - 1) {
        bodyTrials.push({
          type: jsPsychHtmlKeyboardResponse,
          stimulus: '',
          choices: "NO_KEYS",
          trial_duration: 2000,
          data: {
            task: 'rest',
            phase: 'body',
            block: 'body_presentation',
            trial_index: index + 1,
            total_trials: shuffledBodyImages.length
          }
        });
      }
    });

    // 按顺序添加到主时间线：先食物试次，再过渡，再第二个校准环节，再身材试次
    timeline.push({ timeline: foodTrials });
    timeline.push(phaseTransition);
    timeline.push(second_calibration_instructions);
    timeline.push(second_calibration);
    timeline.push(second_validation_instructions);
    timeline.push(second_validation);
    timeline.push(second_recalibrate);
    timeline.push(second_calibration_done);
    timeline.push({ timeline: bodyTrials });

    /* ==== 数据处理和GitHub上传 ==== */
    const dataProcessingTrial = {
      type: jsPsychHtmlButtonResponse,
      stimulus: function() {
        return `
          <div class="centered-text">
            <p>实验完成！正在处理数据...</p>
            <div class="status-message status-loading" id="status-message">
              数据计算中，请稍候...
            </div>
          </div>
        `;
      },
      choices: [],
      on_load: async function() {
        let predictionResult = null;
        let diagnosticReportHTML = ''; // 在此处声明诊断报告变量
        let reportId = '';
        let reportDate = '';
  try {
    const statusMessage = document.getElementById('status-message');

    // 收集所有实验数据
    const allData = jsPsych.data.get().filter({task: 'view'}).values();

    // 计算眼动数据点总数
    const dataPoints = allData.reduce((total, trial) => {
      return total + (trial.gaze_data ? trial.gaze_data.length : 0);
    }, 0);

    // 汇总分析结果
    aggregateResults(allData);

// 使用模型进行预测
if (modelLoaded) {
  predictionResult = await predictEatingDisorder(analysisResults);
  console.log('进食障碍预测结果:', predictionResult);

  // 生成诊断报告
  const reportType = predictionResult.predictedClass === 1 ? 'abnormal' : 'normal';
  reportId = `${userInfo.subjectId}_${userInfo.session}_${Date.now()}`;
  const now = new Date();
  reportDate = `${now.getFullYear()}年${(now.getMonth()+1).toString().padStart(2, '0')}月${now.getDate().toString().padStart(2, '0')}日`;

diagnosticReportHTML = diagnosticReports[reportType]
    .replace(/{reportId}/g, reportId)
    .replace(/{reportDate}/g, reportDate)
    .replace(/{subjectId}/g, userInfo.subjectId);

} else {
  console.warn('模型未加载，跳过预测');
}
          // 生成结果表格
          let resultsTable = generateResultsTable(predictionResult);
          let resultsCSV = generateResultsCSV(predictionResult);

          // 生成CSV数据（原始数据）
          const csvData = allData.map(trial => {
            // 基础信息
            const baseData = {
              trial_id: trial.trial_index,
              phase: trial.phase,
              image_type: trial.image_type,
              image_attribute: trial.image_attribute,
              image_position: trial.image_position,
              original_index: trial.original_index,
              image_src: trial.image_src,
              start_time: trial.trial_start_time,
              end_time: trial.trial_end_time,
              duration: trial.trial_duration_actual
            };

            // 如果有眼动数据，添加第一条和最后一条作为示例
            if (trial.gaze_data && trial.gaze_data.length > 0) {
              baseData.first_gaze_x = trial.gaze_data[0].x;
              baseData.first_gaze_y = trial.gaze_data[0].y;
              baseData.last_gaze_x = trial.gaze_data[trial.gaze_data.length - 1].x;
              baseData.last_gaze_y = trial.gaze_data[trial.gaze_data.length - 1].y;
              baseData.gaze_samples = trial.gaze_data.length;
            }

            // 添加分析结果
            if (trial.analysisResult) {
              baseData.dwell_time = trial.analysisResult.dwellTime;
              baseData.first_fixation = trial.analysisResult.firstFixation;
              baseData.regression_count = trial.analysisResult.regressionCount;
            }

            return baseData;
          });

          // 转换为CSV字符串
          let csvContent = Object.keys(csvData[0]).join(',') + '\n';
          csvData.forEach(row => {
            csvContent += Object.values(row).join(',') + '\n';
          });

          // 转换为JSON字符串
          const jsonContent = JSON.stringify(allData, null, 2);

          // 生成文件名（新格式：csv_eye-00X_01_part1）
          const subjectIdNum = userInfo.subjectId.replace('eye-', '').padStart(3, '0');
          const sessionStr = userInfo.session.toString().padStart(2, '0');
          const timestamp = Date.now(); // 添加时间戳确保唯一性
          const csvFileName = `csv_eye-${subjectIdNum}_${sessionStr}_${timestamp}.csv`;
          const jsonFileName = `json_eye-${subjectIdNum}_${sessionStr}_${timestamp}.json`;
          const resultsFileName = `results_eye-${subjectIdNum}_${sessionStr}_${timestamp}.csv`;

          // 如果摄像头权限被拒绝，跳过GitHub上传
          if (cameraPermissionDenied) {
            statusMessage.className = "status-message status-error";
            statusMessage.textContent = "眼动数据未记录（摄像头权限被拒绝）";

            // 显示结果表格
            document.querySelector('.jspsych-content').innerHTML = `
              <div class="centered-text">
                <h2>第 ${userInfo.session} 次实验完成</h2>
                <p class="warning">眼动数据未记录（摄像头权限被拒绝）</p>
                ${resultsTable}
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 30px;">
                  <button class="save-button" id="save-csv-btn">保存CSV到本地</button>
                  <button class="save-button" id="save-json-btn">保存JSON到本地</button>
                  <button class="save-button" id="save-results-btn">保存结果表格</button>
                  <button class="exit-button" id="exit-btn">退出实验</button>
                </div>
              </div>
            `;

            // 添加按钮事件
            document.getElementById('save-csv-btn').addEventListener('click', function() {
              saveCSVToLocal(csvContent, csvFileName);
            });

            document.getElementById('save-json-btn').addEventListener('click', function() {
              saveJSONToLocal(jsonContent, jsonFileName);
            });

            document.getElementById('save-results-btn').addEventListener('click', function() {
              saveCSVToLocal(resultsCSV, resultsFileName);
            });

            document.getElementById('exit-btn').addEventListener('click', function() {
              location.reload();
            });

            return;
          }

          // 上传数据的核心函数
          const uploadData = async () => {
            // 1. 创建或获取GitHub Issue（每个被试只创建一个）
            statusMessage.textContent = "连接GitHub仓库...";
            const issue = await getOrCreateIssue();

            // 2. 生成GitHub评论内容（包含预测结果）
            statusMessage.textContent = "生成数据报告...";
            const commentBody = generateGitHubComment(dataPoints, predictionResult);

            // 3. 添加评论到Issue（每次的数据作为一条评论）
            statusMessage.textContent = "上传数据到GitHub Issues...";
            await addIssueComment(issue.number, commentBody);

            // 4. 上传CSV文件到data1目录（使用新文件名格式）
            statusMessage.textContent = "上传CSV文件到data1目录...";
            await uploadFileToGitHub(csvContent, csvFileName, 'data1');

            // 5. 上传JSON文件到data2目录（使用新文件名格式）
            statusMessage.textContent = "上传JSON文件到data2目录...";
            await uploadFileToGitHub(jsonContent, jsonFileName, 'data2');

            // 6. 上传结果文件到results目录
            statusMessage.textContent = "上传结果文件到results目录...";
            await uploadFileToGitHub(resultsCSV, resultsFileName, 'results');

            // 7. 更新次数记录
            localStorage.setItem(`session_${userInfo.subjectId}`, userInfo.session.toString());

            // 8. 更新状态显示
            statusMessage.className = "status-message status-success";
            statusMessage.textContent = "数据上传成功！";

            // 9. 显示数据报告和操作按钮
            let content = `
              <div class="centered-text">
                <h2>第 ${userInfo.session} 次实验完成</h2>
                <p>详细眼动数据已成功上传至GitHub仓库</p>
            `;
            // 如果有预测结果，显示诊断报告
          if (predictionResult && diagnosticReportHTML) {
            content += diagnosticReportHTML;
          }

            content += `
                ${resultsTable}
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap; margin-top: 30px;">
                  <button class="copy-button" id="copy-btn">复制报告摘要</button>
                  <button class="github-button" id="github-btn">查看GitHub记录</button>
                  <button class="save-button" id="save-csv-btn">保存CSV到本地</button>
                  <button class="save-button" id="save-json-btn">保存JSON到本地</button>
                  <button class="save-button" id="save-results-btn">保存结果表格</button>
                  <button class="save-button" id="save-report-btn">保存诊断报告</button>
                  <button class="exit-button" id="exit-btn">退出实验</button>
                </div>
              </div>
            `;

            document.querySelector('.jspsych-content').innerHTML = content;

            // 添加按钮事件
document.getElementById('copy-btn').addEventListener('click', function() {
  const summary = `被试ID: ${userInfo.subjectId}\n实验次数: ${userInfo.session}\n数据点数量: ${dataPoints}\n文件位置: data1/${csvFileName} 和 data2/${jsonFileName}`;

  navigator.clipboard.writeText(summary)
    .then(() => alert('报告摘要已复制到剪贴板'))
    .catch(err => console.error('复制失败:', err));
});

            // GitHub查看权限验证
            document.getElementById('github-btn').addEventListener('click', function() {
              const authModal = document.getElementById('auth-modal');
              const authError = document.getElementById('auth-error');
              const authCode = document.getElementById('auth-code');

              // 重置验证状态
              authError.style.display = 'none';
              authCode.value = '';

              // 显示验证弹窗
              authModal.style.display = 'flex';

              // 确认按钮事件
              document.getElementById('auth-confirm').onclick = function() {
                if (authCode.value.toLowerCase() === 'eye') {
                  window.open(issue.html_url, '_blank');
                  authModal.style.display = 'none';
                } else {
                  authError.style.display = 'block';
                }
              };

              // 返回按钮事件
              document.getElementById('auth-cancel').onclick = function() {
                authModal.style.display = 'none';
              };
            });

            // 保存CSV到本地按钮（使用新文件名格式）
            document.getElementById('save-csv-btn').addEventListener('click', function() {
              saveCSVToLocal(csvContent, csvFileName);
            });

            // 保存JSON到本地按钮（使用新文件名格式）
            document.getElementById('save-json-btn').addEventListener('click', function() {
              saveJSONToLocal(jsonContent, jsonFileName);
            });

            // 保存结果表格按钮
            document.getElementById('save-results-btn').addEventListener('click', function() {
              saveCSVToLocal(resultsCSV, resultsFileName);
            });
 // 保存诊断报告按钮事件处理
          if (predictionResult) {
            document.getElementById('save-report-btn').addEventListener('click', function() {
              // 创建报告文本内容
              let reportText = `进食障碍风险眼动测评报告\n`;
              reportText += `报告编号: REPORT-${reportId}\n`;
              reportText += `测评日期: ${reportDate}\n`;
              reportText += `姓名: ${userInfo.subjectId}\n\n`;

              if (predictionResult.predictedClass === 1) {
                reportText += `尊敬的参与者，感谢您完成本次测评。您的整体进食障碍风险等级评估为：异常。\n\n`;
                reportText += `您的注意模式显示出明显的进食障碍认知偏差，建议寻求专业咨询或评估。\n\n`;
                reportText += `建议:\n`;
                reportText += `- 专业咨询：我们强烈建议您与心理咨询师或辅导员进行一次谈话。\n`;
                reportText += `- 行动步骤：您可以联系：全国心理援助热线：12356 或 北京心理援助热线：010-82951332。\n`;
                reportText += `- 避免独自挣扎：与一位您信任的朋友或家人聊聊您的感受。\n`;
              } else {
                reportText += `尊敬的参与者，感谢您完成本次测评。您的整体进食障碍风险等级评估为：健康。\n\n`;
                reportText += `您的注意模式与健康人群相似，未显示出显著的进食障碍相关认知偏差。\n\n`;
                reportText += `建议:\n`;
                reportText += `- 保持当前良好的生活习惯。\n`;
                reportText += `- 可以阅读相关科普资料，增进对心理健康的认识，起到预防作用。\n`;
                reportText += `- 如果您未来感到压力或困扰，随时可以重新测评。\n`;
              }

              reportText += `\n免责声明：本报告由人工智能算法生成，仅作为筛查和参考工具，不能作为临床诊断的唯一依据。\n`;
              reportText += `最终的诊断必须由合格的医疗专业人员通过面谈和评估做出。\n`;

              // 保存为文本文件
              const blob = new Blob([reportText], { type: 'text/plain;charset=utf-8' });
              const url = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = url;
              a.download = `诊断报告_${userInfo.subjectId}_${reportDate}.txt`;
              document.body.appendChild(a);
              a.click();
              document.body.removeChild(a);
            });
          }
            // 退出实验按钮 - 改为刷新页面
            document.getElementById('exit-btn').addEventListener('click', function() {
              location.reload(); // 刷新页面回到登录界面
            });
          };

          // 执行上传
          await uploadData();

        } catch (error) {
          predictionResult = null;
          const statusMessage = document.getElementById('status-message');
          statusMessage.className = "status-message status-error";
          statusMessage.textContent = `数据处理失败: ${error.message}`;
          console.error('完整错误信息:', error);

          // 获取数据用于本地保存
          const allData = jsPsych.data.get().filter({task: 'view'}).values();

          // 汇总分析结果
          aggregateResults(allData);

          // 生成结果表格
          const resultsTable = generateResultsTable();
          const resultsCSV = generateResultsCSV();

          // 生成CSV数据
          const csvData = allData.map(trial => {
            const baseData = {
              trial_id: trial.trial_index,
              phase: trial.phase,
              image_type: trial.image_type,
              image_attribute: trial.image_attribute,
              image_position: trial.image_position,
              original_index: trial.original_index,
              image_src: trial.image_src,
              start_time: trial.trial_start_time,
              end_time: trial.trial_end_time,
              duration: trial.trial_duration_actual
            };
            if (trial.gaze_data && trial.gaze_data.length > 0) {
              baseData.first_gaze_x = trial.gaze_data[0].x;
              baseData.first_gaze_y = trial.gaze_data[0].y;
              baseData.last_gaze_x = trial.gaze_data[trial.gaze_data.length - 1].x;
              baseData.last_gaze_y = trial.gaze_data[trial.gaze_data.length - 1].y;
              baseData.gaze_samples = trial.gaze_data.length;
            }
            if (trial.analysisResult) {
              baseData.dwell_time = trial.analysisResult.dwellTime;
              baseData.first_fixation = trial.analysisResult.firstFixation;
              baseData.regression_count = trial.analysisResult.regressionCount;
            }
            return baseData;
          });

          let csvContent = Object.keys(csvData[0]).join(',') + '\n';
          csvData.forEach(row => {
            csvContent += Object.values(row).join(',') + '\n';
          });

          const jsonContent = JSON.stringify(allData, null, 2);

          // 生成新格式文件名（添加时间戳确保唯一性）
          const subjectIdNum = userInfo.subjectId.replace('eye-', '').padStart(3, '0');
          const sessionStr = userInfo.session.toString().padStart(2, '0');
          const timestamp = Date.now();
          const csvFileName = `csv_eye-${subjectIdNum}_${sessionStr}_${timestamp}.csv`;
          const jsonFileName = `json_eye-${subjectIdNum}_${sessionStr}_${timestamp}.json`;
          const resultsFileName = `results_eye-${subjectIdNum}_${sessionStr}_${timestamp}.csv`;

          // 显示错误恢复选项
          document.querySelector('.jspsych-content').innerHTML += `
            <div class="error-panel">
              <h4>数据上传失败处理方案</h4>
              <p>系统无法自动上传数据到服务器，请选择以下操作:</p>
              <p><strong>错误原因:</strong> ${error.message}</p>
              <ul>
                <li>检查您的网络连接后重试</li>
                <li>保存数据到本地并稍后提交给实验负责人</li>
                <li>退出实验并重新开始</li>
              </ul>
            </div>
            ${resultsTable}
            <div style="margin-top: 20px; text-align: center;">
              <button class="login-button" id="retry-btn">重试上传</button>
              <button class="save-button" id="save-csv-btn">保存CSV到本地</button>
              <button class="save-button" id="save-json-btn">保存JSON到本地</button>
              <button class="save-button" id="save-results-btn">保存结果表格</button>
              <button class="exit-button" id="exit-btn">退出实验</button>
            </div>
          `;

          // 重试上传按钮
          document.getElementById('retry-btn').addEventListener('click', async () => {
            const statusMessage = document.getElementById('status-message');
            statusMessage.className = "status-message status-loading";
            statusMessage.textContent = "正在重试上传数据...";

            try {
              // 重新执行上传逻辑
              const issue = await getOrCreateIssue();
              const commentBody = generateGitHubComment(dataPoints);
              await addIssueComment(issue.number, commentBody);
              await uploadFileToGitHub(csvContent, csvFileName, 'data1');
              await uploadFileToGitHub(jsonContent, jsonFileName, 'data2');
              await uploadFileToGitHub(resultsCSV, resultsFileName, 'results');

              // 更新次数记录
              localStorage.setItem(`session_${userInfo.subjectId}`, userInfo.session.toString());

              statusMessage.className = "status-message status-success";
              statusMessage.textContent = "数据上传成功！";

              // 刷新页面
              setTimeout(() => location.reload(), 2000);

            } catch (retryError) {
              statusMessage.className = "status-message status-error";
              statusMessage.textContent = `重试失败: ${retryError.message}`;
              console.error('重试错误信息:', retryError);
            }
          });

          // 保存CSV按钮（使用新文件名格式）
          document.getElementById('save-csv-btn').addEventListener('click', function() {
            saveCSVToLocal(csvContent, csvFileName);
            // 更新实验次数
            localStorage.setItem(`session_${userInfo.subjectId}`, userInfo.session.toString());
          });

          // 保存JSON按钮（使用新文件名格式）
          document.getElementById('save-json-btn').addEventListener('click', function() {
            saveJSONToLocal(jsonContent, jsonFileName);
            // 更新实验次数
            localStorage.setItem(`session_${userInfo.subjectId}`, userInfo.session.toString());
          });

          // 保存结果表格按钮
          document.getElementById('save-results-btn').addEventListener('click', function() {
            saveCSVToLocal(resultsCSV, resultsFileName);
            // 更新实验次数
            localStorage.setItem(`session_${userInfo.subjectId}`, userInfo.session.toString());
          });

          // 退出实验按钮 - 改为刷新页面
          document.getElementById('exit-btn').addEventListener('click', function() {
            location.reload(); // 刷新页面回到登录界面
          });
        }
      }
    };
// 在timeline开始前添加模型加载
const preExperimentSetup = {
  type: jsPsychCallFunction,
  func: async function() {
    console.log('开始加载模型...');
    const modelLoaded = await loadModel();
    if (modelLoaded) {
      console.log('模型加载成功');
    } else {
      console.warn('模型加载失败，预测功能将不可用');
    }
  }
};
// 将preExperimentSetup添加到timeline开头
timeline.unshift(preExperimentSetup);

// 数据处理和GitHub上传
timeline.push(dataProcessingTrial);

/* ==== 运行实验 ==== */
jsPsych.run(timeline);
  </script>
</body>
</html>
